import numpy as np
from numpy.polynomial import Polynomial
from fastcore.foundation import patch_to
from os import sys
import random
import math
from sympy import nextprime, mod_inverse, primitive_root
import copy

# First we set the parameters

#is_random_param = True
is_random_param = False

#############################
# Test Option 1: Targeted Test Params

# Testcase 1
N = 4
ckks_vector = [1.1 + 4.3j, 3.5 - 1.4j]
ckks_vector2 = [-5 - 6j, 7 + 8j]
rotation_offset = 1

# Testcase 2
#N = 8
#ckks_vector = [1 + 2j, -3 + 4j, 5 - 6j, -7 -8j]
#ckks_vector2 = [0, 0, 0, 0]
#rotation_offset = 3

scale = 1024
Q = scale*scale

is_homogeneous_rotation = True

def EvaluateTargetedCyclotomicPolynomial(x):
	return (x ** N) + 1

#############################
# Test Option 2: Random Test Params

test_count = 1000

N_LOWER = 8
N_UPPER = 8

P_LOWER = 35
P_UPPER = 10000

scale_LOWER = 1
scale_UPPER = 64

def EvaluateRandomCyclotomicPolynomial(x):
	return (x ** N) + 1

##############################################



N_inverse = -1
primitive_root_of_unity = -1

test_index = 0
M = N*2

def IsPowerOf2(N : int):
	n_checker = N
	while n_checker > 1:
		if n_checker % 2 == 1:
			return False
		n_checker /= 2 
	return True


def Egcd(a, b):
	if a == 0:
		return (b, 0, 1)
	else:
		g, y, x = Egcd(b % a, a)
		return (g, x - (b // a) * y, y)

def ModInv(a, m):
	g, x, y = Egcd(a, m)
	if g != 1:
		#raise Exception('modular inverse does not exist')
		return -1
	else:
		return x % m


def GenerateParam():
	global N
	global P
	global ckks_vector
	global gfv_vector2
	global ckks_vector
	global ckks_vector2
	global M
	global N_inverse
	global primitive_root_of_unity
	#global scale_inverse
	global scale
	global Q

	if is_random_param:
		# Decide the exponent N
		while True:
			power = random.randint(N_LOWER, N_UPPER)
			if IsPowerOf2(power):
				 N = power
				 P = random.randint(P_LOWER, P_UPPER)
				 scale = random.randint(scale_LOWER, scale_UPPER)
				 M = N * 2
				 break
			rotation_offset = random.randint(0, N // 2 - 1)
	else:
		if len(ckks_vector)*2 != N or len(ckks_vector2)*2 != N:
		  print("Error: The dimensions of the input vectors are not " + str(N) + ", but " + str(len(ckks_vector)) + ", " + str(len(ckks_vector2)))
		  sys.exit()
	if M <= 0:
		print("Error: M has to be specified for a targeted test")
		sys.exit()

	N_inverse = 1/N
	root_values = []

	primitive_root_of_unity = np.exp(2 * np.pi * 1j / M) 
	print(primitive_root_of_unity)
	next_root = primitive_root_of_unity
	for i in range(N):
		root_values.append(next_root)
		next_root = next_root * (primitive_root_of_unity ** 2) 
		if next_root == primitive_root_of_unity:
			break
#	'''

	print("==================== PARAMETERS ====================")
	print("N: " + str(N))
	print("Ciphertext modulus: " + str(Q))
	print("Scale Factor: " + str(scale))
	print("Selected primitive " + str(M) + "-th root of unity: " + str(primitive_root_of_unity))
	print("- " + str(N) + " roots of the " + str(M) + '-th cyclotomic polynomial : ' + str(root_values))
	print()
	for root in root_values:
		generated_roots = []
		coprimes = []
		for exp in range(M):
			if exp != 0 and math.gcd(exp, M) == 1:
				coprimes.append(exp)
				generated_roots.append((int(root) ** exp) )
		print('- Roots of the ' + str(M) + '-th cyclotomic polynomial generated by the co-prime-' + str(coprimes) + '-exponented primitive ' + str(M) + '-th root of unity ' + str(root) + ' : ' + str(generated_roots))
	print()
	for root in root_values:
		generated_roots = []
		exponents = []
		for exp in range(M):
				exponents.append(exp)
				generated_roots.append((int(root) ** exp) )
		print('- All ' + str(M) + '-th roots of unity generated by the ' + str(exponents) + '-exponented primitive ' + str(M) + '-th root of unity ' + str(root) + ' : ' + str(generated_roots))
	print()

	if is_random_param:
		ckks_vector = []
		ckks_vector2 = []
		for i in range(N//2):
			ckks_vector.append(random.uniform(1.0, 10.0) + 1j * random.uniform(1.0, 10.0))
			ckks_vector2.append(random.uniform(1.0, 10.0) + 1j * random.uniform(1.0, 10.0))

np.set_printoptions(suppress=True)


def JFunction(h, is_plus: bool):
	if is_plus: 
		return (5 ** h) % (2*N)
	else:
		return (-(5 ** h)) % (2*N)

def isprime(n):
	'''check if integer n is a prime'''
	# make sure n is a positive integer
	n = abs(int(n))
	# 0 and 1 are not primes
	if n < 2:
		return False
	# 2 is the only even prime number
	if n == 2: 
		return True	
	# all other even numbers are not primes
	if not n & 1: 
		return False
	# range starts with 3 and only needs to go up the squareroot of n
	# for all odd numbers
	for x in range(3, int(n**0.5)+1, 2):
		if n % x == 0:
			return False
	return True


def VectorDataSizeToInfinite(vector):
	# Convert the matrix to dtype=object to allow arbitrary integer sizes
	vector_object = np.array(vector, dtype=object)

	# Convert each element to Python's built-in int type
	for i in range(vector_object.shape[0]):
		vector_object[i] = int(vector_object[i])
	return vector_object

def MatrixDataSizeToInfinite(matrix):
	# Convert the matrix to dtype=object to allow arbitrary integer sizes
	matrix_object = np.array(matrix, dtype=object)

	# Convert each element to Python's built-in int type
	for i in range(matrix_object.shape[0]):
		for j in range(matrix_object.shape[1]):
			matrix_object[i, j] = int(matrix_object[i, j])
	return matrix_object

class CKKSEncoder:
	"""Basic CKKS encoder to encode complex vectors into polynomials."""
	
	def __init__(self):
		"""Initialization of the encoder for M a power of 2. 
		
		xi, which is an M-th root of unity will, be used as a basis for our computations.
		"""
		self.M = M
		self.create_sigma_R_basis()
		

	@staticmethod
	def vandermonde(M: int) -> np.array:
		"""Computes the Vandermonde matrix from a m-th root of unity."""
		global P	 
		global N_inverse
		global N
		matrix = []
		# We will generate each row of the matrix

		cyclic_x_values_ordered = []
		power_array = []
		power_matrix = []
		for h in range(int(N/2)):
			print(JFunction(h, True))
			new_root = (primitive_root_of_unity ** JFunction(h, True))  
			if new_root in cyclic_x_values_ordered:
				 print("Error 1: root " + str(new_root) + " is already in " + str(cyclic_x_values_ordered))
				 sys.exit(0)
			cyclic_x_values_ordered.append(new_root)
			power_array.append(JFunction(h, True))
		for h in reversed(range(int(N/2))):
			new_root = (primitive_root_of_unity ** JFunction(h, False))  
			if new_root in cyclic_x_values_ordered:
				 print("Error 2: root " + str(new_root) + " is already in " + str(cyclic_x_values_ordered))
				 print("N: " + str(N))
				 sys.exit(0)
			cyclic_x_values_ordered.append(new_root)
			power_array.append(JFunction(h, False))

		for x in cyclic_x_values_ordered:
			# For each row we select a different root
			row = []
			# Then we store its powers
			for degree in range(N):
				insert = 1
				for count in range(degree):
					insert = insert * x 
				row.append(insert)
			matrix.append(row)
		return matrix

	def create_sigma_R_basis(self):
		"""Creates the basis (sigma(1), sigma(X), ..., sigma(X** N-1))."""
		self.sigma_R_basis = np.array(np.array(self.vandermonde(self.M)).T, dtype = object)

		# Convert each element to Python's built-in int type, otherwise the computation will overflow!
		#self.sigma_R_basis = MatrixDataSizeToInfinite(self.sigma_R_basis)
		self.sigma_R_basis_counter = self.sigma_R_basis.T

		if is_homogeneous_rotation:

			W_modified = copy.deepcopy(self.sigma_R_basis)
			WT_modified = copy.deepcopy(self.sigma_R_basis_counter)

			for i in range(N):
				for j in range(N // 4):
					val1 = W_modified[i][j]
					val2 = W_modified[i][N//2 - 1 - j]
					W_modified[i][j] = val2
					W_modified[i][N//2 - 1 - j] = val1

			for i in range(N//4):
					val1 = copy.deepcopy(WT_modified[N//2 + i])
					val2 = copy.deepcopy(WT_modified[N - 1 - i])
					WT_modified[N//2 + i] = val2
					WT_modified[N - 1 - i] = val1

			self.sigma_R_basis = W_modified
			self.sigma_R_basis_counter = WT_modified
		print()
		print("<W Matrix>")
		print(self.sigma_R_basis)
		print()
		print("<W^* Matrix>")
		print(self.sigma_R_basis_counter)
		print()
		print("<(W^*)*(W)>")
		print(np.matmul(self.sigma_R_basis_counter, self.sigma_R_basis) )
		print()
					
@patch_to(CKKSEncoder)
def __init__(self):
	self.M = M
	self.create_sigma_R_basis()
	self.scale = scale
	
@patch_to(CKKSEncoder)
def encode(self, input_vector: np.array) -> Polynomial:
	anti_diagonal_matrix = MatrixDataSizeToInfinite(np.eye(N)[::-1])
	print(input_vector)
	for i in range(N // 2):
		lista = [input_vector[i].conjugate()]
		input_vector = np.append(input_vector, lista)
		#print("Appended")
	#print(input_vector)
	basis_coordinates = np.matmul(N_inverse *  self.sigma_R_basis, anti_diagonal_matrix).dot(input_vector) 
	#temp_matrix = np.matmul(self.sigma_R_basis, anti_diagonal_matrix)
	#for i in range(N):
	#	for j in range(N):
	#		print(f'{i}, {j} : {temp_matrix[i][j] * input_vector[j]}')
	#print("Before Scaling")
	#print(basis_coordinates)
	p = Polynomial(basis_coordinates)
	scaled_p = p * self.scale
	scaled_p.coef = [round(c.real) for c in scaled_p.coef]

	#print("After Scaling")
	#print(scaled_p)

	return scaled_p

@patch_to(CKKSEncoder)
def decode(self, p: Polynomial) -> np.array:
	rescaled_p = p / scale
	#print(self.sigma_R_basis)
	#print(rescaled_p.coef)
	coef = rescaled_p.coef
	coef_preserved_zeros = np.pad(coef, (0, N - len(coef)), 'constant')
	#coef_preserved_zeros = VectorDataSizeToInfinite(coef_preserved_zeros)
	z = np.matmul(self.sigma_R_basis_counter, coef_preserved_zeros) 
	return z

def reduce_polynomial(poly, n, q):
	degree = 0
	new_coef = []
	coef = poly.coef
	for co in coef:
		if degree >= n:
			new_coef[degree % n] += co * (-1 ** (degree / n))
			#new_coef[degree % n] %= q 
		else:
			new_coef.append(co)# % q)
		degree += 1
	poly.coef = new_coef
	return poly

def rotate_homomorphic(poly, rotation_offset, n):
	degree = 0
	coef = poly.coef
	new_coef = [0] * n
	#new_coef = VectorDataSizeToInfinite(new_coef)
	power = JFunction(rotation_offset, True)
	for i in range(len(coef)):
		if (((i * power) // n) % 2 == 1):
			new_coef[(i * power) % n] += -coef[i]
		else:
			new_coef[(i * power) % n] += coef[i]
	poly.coef = new_coef
	return poly


def main():

	print("======================================")
	global M
	global N_inverse
	global primitive_root_of_unity

	GenerateParam()
	encoder = CKKSEncoder()

	print("<The CKKS plaintext vector to encode>")
	z = np.array(ckks_vector)
	z2 = np.array(ckks_vector2)
	z3 = (z + z2) 
	z4 = z * z2
	print('vector 1: ' + str(z))
	#p = encoder.encode(z)
	#decoded_z = encoder.decode(p)
	#print('decoded vector 1: ' + str(decoded_z))
	#sys.exit()
	print('vector 2: ' + str(z2))
	print('vector 1 + 2: ' + str(z3 ))
	print('vector 1 * 2: ' + str(z4 ))
	print()

	print("<The encoded CKKS plaintext polynomial>")
	p = encoder.encode(z)
	p2 = encoder.encode(z2)
	p3 = reduce_polynomial(p + p2, N, Q)
	p3_rotated = reduce_polynomial(p + p2, N, Q)
	p3_rotated = rotate_homomorphic(p3_rotated, rotation_offset, N) # divide by a redundant scale factor
	#p4 = reduce_polynomial((p * p2), N, Q)/scale # divide by a redundant scale factor

	print('polynomial 1: ' + str(p))
	print('polynomial 2: ' + str(p2))
	print()
	#print("before polynomial reduction of 1 + 2: " + str(p + p2))
	print('after polynomial reduction of 1 + 2: ' + str(p3))
	print('after polynomial rotation by ' + str(rotation_offset) + ' positions and reduction of 1 + 2: ' + str(p3_rotated))
	print()
	#print('before polynomial reduction of 1 * 2: ' + str(p * p2))
	#print('after polynomial reduction of 1 * 2: ' + str(reduce_polynomial(p * p2, N, Q)))
	#print('after polynomial reduction & scale normalization of 1 * 2 scale normalization: ' + str(p4))
	
	print()

	decoded_z = encoder.decode(p)[:N//2]
	decoded_z2 = encoder.decode(p2)[:N//2] 
	decoded_z3 = encoder.decode(p3)[:N//2]
	#decoded_z4 = encoder.decode(p4)
	decoded_z3_rotated = encoder.decode(p3_rotated)[:N//2]
	print("<The decoded CKKS plaintext vector>")
	print('decoded vector 1: ' + str(decoded_z))
	print('decoded vector 2: ' + str(decoded_z2))
	print('decoded vector 1 + 2: ' + str(decoded_z3))
	#print('decodec vector 1 * 2: ' + str(decoded_z4))
	print('rotated decodec vector 1 + 2 by ' + str(rotation_offset) + ' positions: ' + str(decoded_z3_rotated))
	print()

	for i in range(N//2):
		if abs((z3[i] - decoded_z3[i]).real) > 0.001 or abs((z3[i] - decoded_z3[i]).imag) > 0.01:
			print("vector 1 + 2 is decoded WRONG!")
			print(z3)
			print(decoded_z3)
			sys.exit(0)
	else:
		print("[FINAL DECODED RESULT " + str(test_index) + "] : " + str(z3) + " == " + str(decoded_z3) + " <---- ALMOST CORRECT")
		print()
	for i in range(len(z3)):
		#print(f'Compare {i} vs {i + rotation_offset % (len(z3)//2)}');
		original_index = i
		rotated_index = (i - rotation_offset) % (len(z3))
		if abs((z3[original_index] - decoded_z3_rotated[rotated_index]).real) > 0.001 or abs((z3[original_index] - decoded_z3_rotated[rotated_index]).imag) > 0.001:
			print("Rotation Wrong!")
			print(original_index)
			print(rotated_index)
			print((z3[original_index] - decoded_z3_rotated[rotated_index]).real)
			print((z3[original_index] - decoded_z3_rotated[rotated_index]).imag)
			sys.exit(0)
	print("Rotation is ALMOST CORRECT")

if __name__ == "__main__":
	test_index = 0
	while True:
		main()
		test_index += 1
		if not is_random_param or test_index == test_count:
			break

	if is_random_param:
		print("Total " + str(test_index) + " Tests Passed")

