FHE parameters of BFV, BGV, or CKKS schemes which are secure enough sometimes require the ring size of polynomial coefficients to be 1000 bits or more, which consumes much computational resources for 64-bit CPU architectures. To make the computation efficient, we can alternatively represent the coefficients of ciphertext polynomials by the number residue system (RNS)~\autoref{subsec:crt-application}, which allows modulo addition and multiplication of elements from a large ring (e.g., 1000 bits) by the combination of values computed in small rings (e.g., 32$\sim$64 bits), each of which compactly fits in 64-bit CPU registers. Modern BFV, BGV, and CKKS schemes adopt this RNS approach by default for efficient computation of large values. These are called RNS-variant FHE schemes.  

While RNS can directly compute modulo addition and multiplication, it does not directly support other operations such as \textsf{ModRaise} or modulus switch, which are essential operations for all FHE schemes. This section explains how we can design such corner-case operations based on RNS to accomplish a complete design of RNS-based FHE schemes. Besides BFV, BGV, and CKKS, TFHE can also theoretically use RNS for representing its ciphertext coefficients. However, TFHE's practically used coefficient size is less than $2^{32}$ (or $2^{64}$), which compactly fits in 32-bit (or 64-bit) modern CPU registers. Therefore, TFHE does not need RNS. Thus, this section will focus on RNS-based operations for BFV, BGV, and CKKS. 

Particularly in this section, we assume the modulo reduction $a \bmod q = |a|_q$ implicitly uses a centered (i.e., signed) residue representation (\autoref{subsec:modulo-centered}) whose modulo overflow \& underflow boundaries are $\dfrac{q}{2} - 1$ and $-\dfrac{q}{2}$, respectively. This assumption is necessary to eliminate a certain modulo reduction operation when designing \textsf{FastBconvEx} (\autoref{subsec:rns-fastbconvex})-- by using the assumption of limiting the possible range of certain residue arithmetic as discussed in \autoref{subsec:modulo-centered}. 

\begin{tcolorbox}[
    title = \textbf{Required Background},    % box title
    colback = white,    % light background; tweak to taste
    colframe = black,  % frame colour
    boxrule = 0.8pt,     % line thickness
    left = 1mm, right = 1mm, top = 1mm, bottom = 1mm % inner padding
]

\begin{itemize}
\item \autoref{sec:modulo}: \nameref{sec:modulo}
\item \autoref{sec:group}: \nameref{sec:group}
\item \autoref{sec:field}: \nameref{sec:field}
\item \autoref{sec:polynomial-ring}: \nameref{sec:polynomial-ring}
\item \autoref{sec:decomp}: \nameref{sec:decomp}
\item \autoref{sec:modulus-rescaling}: \nameref{sec:modulus-rescaling}
\item \autoref{sec:chinese-remainder}: \nameref{sec:chinese-remainder}
\item \autoref{sec:polynomial-interpolation}: \nameref{sec:polynomial-interpolation}
\item \autoref{sec:ntt}: \nameref{sec:ntt}
\item \autoref{sec:lattice}: \nameref{sec:lattice}
\item \autoref{sec:rlwe}: \nameref{sec:rlwe}
\item \autoref{sec:glwe}: \nameref{sec:glwe}
\item \autoref{sec:glwe-add-cipher}: \nameref{sec:glwe-add-cipher}
\item \autoref{sec:glwe-add-plain}: \nameref{sec:glwe-add-plain}
\item \autoref{sec:glwe-mult-plain}: \nameref{sec:glwe-mult-plain}
\item \autoref{subsec:modulus-switch-rlwe}: \nameref{subsec:modulus-switch-rlwe}
\item \autoref{sec:glwe-key-switching}: \nameref{sec:glwe-key-switching}
\item \autoref{sec:bfv}: \nameref{sec:bfv}
\item \autoref{sec:ckks}: \nameref{sec:ckks}
\item \autoref{sec:bgv}: \nameref{sec:bgv}
\end{itemize}
\end{tcolorbox}

\clearpage 

\subsection{Fast Base Conversion: \textsf{FastBConv}}
\label{subsec:rns-fastbconv}

\noindent \textbf{- Reference 1:} 
\href{https://eprint.iacr.org/2016/510}{A Full RNS Variant of FV-like Somewhat Homomorphic Encryption Schemes}~\cite{rns-bfv}

\noindent \textbf{- Reference 2:} 
\href{https://eprint.iacr.org/2022/657}{BASALISC: Programmable Hardware Accelerator for BGV FHE}~\cite{rns-bfv2}

$ $


Suppose we have $x \in \mathbb{Z}_q$ (where $q$ is a big modulus). Then, we can express $x$ by using RNS (\autoref{subsec:crt-application}) as $(x_1, x_2, \cdots, x_k)$, where each $x_i \in \mathbb{Z}_{q_i}$, $\prod\limits_{i=1}^k q_i = q$, and $\{q_1, q_2, \cdots, q_k\}$ are co-prime. In RNS, we define base conversion as an operation of converting the RNS residues $(x_1, x_2, \cdots, x_k) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ into $(c_1, c_2, \cdots, c_k) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$, where $\{b_1, b_2, \cdots, b_l\}$ are a new base, and $\{q_1, q_2, \cdots, q_k\}$ and $\{b_1, b_2, \cdots, b_l\}$ are all co-prime. The relationship between $x$ and $c$ is: $c = |x|_b$ (where $x \in \mathbb{Z}_{q}$ and $c \in \mathbb{Z}_b$). The standard way of performing base conversion is assembling $(x_1, x_2, \cdots, x_k)$ into $x$ by computing $x = \sum\limits_{i=1}^k |x_i z_i|_{q_i} \cdot y_i \bmod q$ (where $y_i = \dfrac{q}{q_i} \text{ and } z_i = y_i^{-1} \bmod q_i$), and then computing $c_j \equiv x \bmod b_j$ for $j \in [1, l]$. However, this computation is slow if the modulus $q$ is large. To compute the base conversion \textit{fast}, we design the fast base conversion operation $\textsf{FastBConv}$ as follows: 


\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsec:rns-fastbconv}} Fast Base Conversion: \textsf{FastBConv}}}]


\textbf{\underline{Input}:} $(x_1, x_2, \cdots, x_k) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ \textcolor{red}{ \# which represents the big value $x \in \mathbb{Z}_q$, where $q = \prod\limits_{i=1}^kq_i$, and $\{q_1, q_2, \cdots, q_k\}$ are co-prime}

$ $

$\textsf{FastBConv}(x, q, b)= \textsf{FastBConv}(\{x_i\}_{i=1}^{k}, \{q_i\}_{i=1}^{k}, \{b_i\}_{i=1}^{l})$

$ = \left( \sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i \bmod b_j \right)_{j \in [1,l]}$  

\textcolor{red}{ \# where $y_i = \dfrac{q}{q_i} \text{, } z_i = y_i^{-1} \bmod q_i$, and $b = \prod\limits_{i=1}^lb_i$} 

$ $

$ = (c_1, c_2, \cdots, c_l) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$ \textcolor{red}{ \# which represents the big value $c \in \mathbb{Z}_b$}

$ $

$ $

The input to this \textsf{FastBConv} function is a list of RNS residues $(x_1, x_2, \cdots, x_k)$ having the prime moduli $(q_1, q_2, \cdots, q_k)$ as the base. This RNS vector represents the big value:

$x = \left(\sum\limits_{i=1}^k x_i\cdot y_i \cdot z_i\right) \bmod q = \left(\sum\limits_{i=1}^k |x_i\cdot z_i|_{q_i} \cdot y_i\right) \bmod q$ \textcolor{red}{ \# Theorem~\ref*{sec:chinese-remainder}.1}

$ $

The output of this \textsf{FastBConv} function is a list of RNS residues $(c_1, c_2, \cdots, c_l)$ having the prime moduli $(b_1, b_2, \cdots, b_l)$ as the base. This RNS vector represents the big value 

$c = \left(\sum\limits_{i=1}^l c_i\cdot y'_i \cdot z'_i\right) \bmod b = \left(\sum\limits_{i=1}^l |c_i\cdot z'_i|_{b_i} \cdot y'_i\right) \bmod b$ \textcolor{red}{ \# where $y'_i = \dfrac{b}{b_i}$ and $z'_i = {y_{i}'}^{-1} \bmod b_i$}

$ $

The relationship between $c$ and $x$ is as follows: 

$c = x + uq \bmod b$ (where $u$ is an integer with the magnitude $|u| \leq \dfrac{k}{2} + 1$) 

\textcolor{red}{ \# i.e. the fast-base-converted $c$ gets noise $|uq|_b$}


\end{tcolorbox}


\begin{myproof}

We will prove why a fast base conversion of $x$ into $c$ gets an additional noise $|u\cdot q|_b$ (where integer $|u| \leq \dfrac{k}{2}+1$) compared to a standard base conversion. If we did a standard (i.e., exact) base conversion of $x$ from base moduli $(q_1, \cdots, q_k)$ to $(b_1, \cdots, b_l)$, then we would compute the following:

$$
\left( \left( \sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i \bmod q \right) \bmod b_j \right)_{j \in [1,l]} = \left( x \bmod b_j \right)_{j \in [1,l]}
$$

But $\textsf{FastBConv}$ omits the intermediate (big) reduction modulo $q$ and directly applies (small) reduction modulo $b_j$ for the sake of fast computation, so that our conversion process does not need to handle large values whose magnitude can be as large as $\pm\dfrac{q}{2}$. In this approach of fast base conversion, for each $i \in [1, k]$, the computation result of $|x_i \cdot z_i|_{q_i} \cdot y_i$ is some value between $\left[-\left\lceil\dfrac{q}{2}\right\rceil, \left\lfloor\dfrac{q}{2}\right\rfloor\right]$, because $|x_i \cdot z_i|_{q_i}$ is some integer between $\left[-\left\lceil\dfrac{q_i}{2}\right\rceil, \left\lfloor\dfrac{q_i}{2}\right\rfloor\right]$ and $y_i = \dfrac{q}{q_i}$. Therefore, $-\dfrac{q+1}{2} \leq |x_i \cdot z_i|_{q_i} \cdot y_i \leq \dfrac{q}{2}$. If we sum $k$ such values for $i \in [1, k]$, then the total sum $x' = \sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i = x + u\cdot q$ (Summary~\ref*{sec:chinese-remainder} in \autoref{sec:chinese-remainder}) for some integer $u$ (where $u\cdot q$ represents the $q$-multiple overflows). And since we have shown that $-\dfrac{q+1}{2} \leq |x_i \cdot z_i|_{q_i} \cdot y_i \leq \dfrac{q}{2}$ for each $i \in [1, k]$, $uq$ has to be greater than $-k\cdot\dfrac{q+1}{2}$ and smaller than $k\cdot\dfrac{q}{2}$ (i.e., $u$ is an integer between $-\dfrac{k}{2} - 1 \leq u \leq \dfrac{k}{2}$). Therefore, $\sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i$ can have maximum $-\left(\dfrac{k}{2} + 1\right)\cdot q$ underflows and $\dfrac{k}{2}\cdot q$ overflows. Thus, while standard (i.e., exact) base conversion computes each residue as $\hat{c}_j = \left(\sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i \bmod q\right) \bmod b_j$ (i.e., $\hat{c}_j = x \bmod b_j$), fast (i.e., approximate) base conversion computes each residue as $c_j = \left(\sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i\right) \bmod b_j$ (i.e., $c_j = x + uq \bmod b_j$, where integer $|u| \leq \dfrac{k}{2} + 1$). Notice that the residual difference (i.e., error) between each $\hat{c}_j$ and $c_j$ is $uq \bmod b_j$, and the collective noise generated by fast base conversion from $q \rightarrow  b$ is  $uq \bmod b$. Also, note that the RNS residue vector $(c_1, c_2, \cdots, c_l) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$ represents the big value $c = x + uq \bmod b$. 

Importantly, \textsf{FastBConv} does not guarantee the correctness of base conversion, because the $q$-multiple overflow would generate a non-negligible error. Yet, \textsf{FastBConv} is used as an essential building block for various RNS-based operations such as \textsf{ModRaise\textsubscript{RNS}} (\autoref{subsec:rns-modraise}) and \textsf{ModSwitch\textsubscript{RNS}} (\autoref{subsec:rns-modswitch}).  

\end{myproof}






\subsection{RNS-based ModRaise: \textsf{ModRaise\textsubscript{RNS}}}
\label{subsec:rns-modraise}

\noindent \textbf{- Reference:} 
\href{https://eprint.iacr.org/2018/931.pdf}{A Full RNS Variant of
Approximate Homomorphic Encryption}~\cite{rns-ckks}

$ $

\textsf{ModRaise} is an operation of raising a ciphertext's modulus from $q$ to $qb$ (where $q \ll qb$). We used \textsf{ModRaise} in BFV's ciphertext-to-ciphertext multiplication (Summary~\ref*{subsubsec:bfv-mult-cipher-summary} in \autoref{subsubsec:bfv-mult-cipher-summary}) and in CKKS's modulus bootstrapping (Summary~\ref*{subsubsec:ckks-bootstrapping-summary} in \autoref{subsubsec:ckks-bootstrapping-summary}). The RNS-based \textsf{ModRaise} operation is designed as follows:


\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsec:rns-modraise}} \textsf{ModRaise\textsubscript{RNS}}}}]

\textbf{\underline{Input}:} $(x_1, x_2, \cdots, x_k) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ \textcolor{red}{ \# which represents the big value $x \in \mathbb{Z}_q$}

$ $


$\textsf{ModRaise\textsubscript{RNS}}({\{x_i\}_{i=1}}^k, q, qb)$ \textcolor{red}{ \# where $q$ and $b$ are co-prime}

$= \textsf{FastBConv\textsubscript{RNS}}({\{x_i\}_{i=1}}^k, q, qb)$ 

$ = (x_1, x_2, \cdots, x_k, \textsf{FastBConv}(\{x_i\}_{i=1}^k, q, b))$ 

$ = (x_1, x_2, \cdots, x_k, c_1, c_2, \cdots, c_l) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$

$ = (\chi_1, \chi_2, \cdots, \chi_{k+l}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$

\textcolor{red}{ \# which represents the value $\chi \in \mathbb{Z}_{qb}$}

$ $


The relationship between $\chi$ and $x$ is as follows: 

$\chi \equiv x + u\cdot q \bmod qb$ \textcolor{red}{ \# the noise generated by \textsf{ModRaise\textsubscript{RNS}} is $|uq|_{qb}$ (where integer $|u| \leq \dfrac{k}{2}+1$)}

$\chi \equiv x \bmod q$

\end{tcolorbox}


\begin{myproof}

In \autoref{subsec:rns-fastbconv}, we proved that $x' = \sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i = x + u\cdot q$ (where integer $|u| \leq \dfrac{k}{2}+1$). Therefore, the following holds:

$x' \equiv x_i \bmod q_i$ for $i \in [1, k]$ \textcolor{red}{ \# since $x' = x + u\cdot q \equiv x_i \bmod q_i$ (as $q_i$ divides $q$, so $x \equiv x_i \bmod q_i$)}

$x' \equiv c_j \bmod b_j$ for $j \in [1, l]$ \textcolor{red}{ \# where each $c_j = x + uq \bmod b_j$}

$ $

Therefore, $x' \bmod qb$ can be represented as the following RNS residues: 

$(x_1, x_2, \cdots, x_k, c_1, c_2, \cdots, c_l) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$

$ = (x_1, x_2, \cdots, x_k, \textsf{FastBConv}(\{x_i\}_{i=1}^k, q, b)) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$ 

$ $

Our ideal goal of mod-raising $x \in \mathbb{Z}_q$ from $q \rightarrow qb$ is to derive an RNS vector of $x \bmod qb$. However, the above RNS vector represents $x' \bmod qb$, where $x' = x + uq$ (with integer $|u| \leq \dfrac{k}{2}+1$). Therefore, we can interpret the above RNS vector as representing $x \bmod qb$ with the additional noise $|uq|_{qb}$.

%$ $

%To summarize the notations, we denote $\chi = x' \bmod qb = (x + uq) \bmod qb$. In other words, the above RNS vector represents the big number $\chi \in [0, qb]$. Note that $x'$ is not the same as $\chi$, because $\chi \in [0, qb)$, whereas $x'$ can have $qb$-multiple overflows. We can derive $\chi$ by computing: 

%$\chi = \bm\left(\left(\sum\limits_{i=1}^k x_i\cdot \hat{y}_i \cdot \hat{z}_i\right) + \left(\sum\limits_{i=1}^l c_i\cdot \hat{y}'_i \cdot \hat{z}'_i\right)\bm\right) \bmod qb$ 

%\textcolor{red}{\# where $\hat{y}_i = \dfrac{qb}{q_i}$, $\hat{y}'_i = \dfrac{qb}{b_i}$, $\hat{z}_i = \hat{y}^{-1}_i$, and $\hat{z}'_i = \hat{y}'^{-1}_i$}

\end{myproof}

\subsection{RNS-based ModDrop: \textsf{ModDrop\textsubscript{RNS}}}
\label{subsec:rns-moddrop}

\textsf{ModDrop} (\autoref{subsec:ckks-moddrop}, \autoref{subsec:bgv-moddrop}) is an operation of decreasing a ciphertext's modulus from $q \rightarrow q'$ (where $q'$ divides $q$) without affecting the plaintext's scaling factor(in the case of CKKS) or the noise's scaling factor (in the case of BGV). 

In an RNS-based ciphertext representation, \textsf{ModDrop} is equivalent to removing some of the base moduli in the ciphertext without affecting the scaling factor $\Delta$. This can be achieved by converting the ciphertext's base from $q$ to $\bar{q}$ where the base moduli set of $\bar{q}$ are a subset of that of $q$; that is, $\bar{q}$ divides $q$. Specifically, suppose that we have an input $(x_1, x_2, \cdots, x_k) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$, and a new subset base $\bar{q} = q_1 \cdot q_2 \cdot \cdots \cdot q_{k'}$, where $k' < k$. In this setup, the fast base conversion from $q \rightarrow \bar{q}$ is equivalent to simply extracting the input value's RNS residues associated with the base moduli $(q_1, q_2, \cdots, q_{k'})$. This is because of the following reasoning:

$\textsf{FastBConv}(\{x_i\}_{i=1}^{k}, q, \bar{q}) = \left( \sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i \bmod q_j \right)_{j \in [1,k']}$  

$ = x + uq \bmod \bar{q}$ \textcolor{red}{ \# Summary~\ref*{subsec:rns-fastbconv} in \autoref{subsec:rns-fastbconv}}

$ = x \bmod \bar{q} $ \textcolor{red}{ \# $uq$ gets eliminated because $\bar{q}$ divides $uq$}


$ = (x_1, x_2, \cdots, x_{k'}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_{k'}}$ 


$ $

Notice that the above fast base conversion from $q \rightarrow \bar{q}$ (where $\bar{q}$ divides $q$) does not generate any noise. This is different from the case of fast base conversion from $q \rightarrow b$ (Summary~\ref*{subsec:rns-fastbconv} in \autoref{subsec:rns-fastbconv}) where $q$ and $b$ are co-prime, which generates the noise $|uq|_b$ (where integer $|u| \leq \dfrac{k}{2}+1$). 

The \textsf{ModDrop} operation is supported in all of BFV, BGV, and CKKS ciphertexts that are represented in RNS forms. However, note that \textsf{ModDrop} is possible only if the scaled plaintext (in the case of BFV and CKKS) or the scaled noise (in the case of BGV) does not exceed the ciphertext modulus after the mod-drop operation, because otherwise correct decryption is not possible. \textsf{ModDrop\textsubscript{RNS}} is summarized as follows:

\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsec:rns-moddrop}} \textsf{ModDrop\textsubscript{RNS}}}}]


\textbf{\underline{Input}:} $(x_1, x_2, \cdots, x_k) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ 

$ $

$\textsf{FastBConv}(\{x_i\}_{i=1}^{k}, q, \bar{q}) = \left( \sum\limits_{i=1}^{k} |x_i \cdot z_i|_{q_i} \cdot y_i \bmod q_j \right)_{j \in [1,k']}$  

\textcolor{red}{ \# where $\bar{q}$ is a product of co-primes $q_1 \cdot q_2 \cdot \cdots \cdot q_{k'}$, and $\bar{q}$ divides $q$} 


$ = (x_1, x_2, \cdots, x_{k'}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_{k'}}$ \textcolor{red}{ \# no noise generated during the conversion}


\end{tcolorbox}





\subsection{RNS-based Modulus Switch: \textsf{ModSwitch\textsubscript{RNS}}}
\label{subsec:rns-modswitch}

Modulus switch is an operation of reducing a ciphertext's modulus from $q$ to $q'$ (where $q' < q$) and updating the target value from $x$ to $\left\lceil x\cdot \dfrac{q'}{q}\right\rfloor$. Modulus switch is used for lowering the multiplicative level of a ciphertext upon each ciphertext-to-ciphertext multiplication (in the case of BFV, CKKS, or BGV) or even upon each ciphertext-to-plaintext multiplication (in the case of CKKS). Upon each modulus switch from $q \rightarrow q'$ of a ciphertext, the scaling factor of the underlying plaintext in the ciphertext also gets reduced by the same proportion: $\dfrac{q'}{q}$. 

The modulus switch operation of an RNS-based ciphertext is denoted as \textsf{ModSwitch\textsubscript{RNS}}, which requires that the output base moduli are a subset of the input base moduli. In other words, like the case of \textsf{ModDrop\textsubscript{RNS}}, it only supports a modulus switch from $qb \rightarrow q$, where $q$ and $b$ are co-prime. 


Suppose we have $(\chi_1, \chi_2, \cdots, \chi_{k+l}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l} $, which represents the value $\chi = \left(\sum\limits_{i=1}^{k}\left|\chi_i\cdot\left(\dfrac{qb}{q_i}\right)^{-1}\right|_{q_i}\cdot\dfrac{qb}{q_i}\right) + \left(\sum\limits_{j=k+1}^{k+l}\left|\chi_j\cdot\left(\dfrac{qb}{b_j}\right)^{-1}\right|_{b_j}\cdot\dfrac{qb}{b_j}\right) \bmod qb$. 

$ $

Given $\chi \in \mathbb{Z}_{qb}$, \textsf{ModSwitch\textsubscript{RNS}} from $qb \rightarrow q$ is an operation of updating $\chi \in \mathbb{Z}_{qb}$ to some $y \in \mathbb{Z}_q$ where $y \approx \left\lceil\dfrac{\chi}{b}\right\rfloor$. Unlike in regular modulus switch where we can directly arithmetically divide $\chi$ by $b$ and round it, an RNS vector is incompatible with direct arithmetic division on the residues. Therefore, our alternative strategy is to find some small value $\hat{\chi}$ such that $\chi \equiv \hat{\chi} \bmod b$. Once we find such $\hat\chi$, then $\chi - \hat{\chi} \bmod qb$ becomes divisible by $b$ (since their difference is some multiple of $b$), and thus we can compute $\dfrac{\chi - \hat{\chi}}{b} \approx \left\lceil\dfrac{\chi}{b}\right\rfloor$. Note that in this computation, the additionally introduced error of modulus switch caused by replacing $\chi$ with $\chi - \hat\chi$ is equivalent to: $\Bigg|\left\lceil\dfrac{\chi}{b}\right\rfloor - \dfrac{\chi - \hat\chi}{b}\Bigg| \approx \left\lceil\dfrac{\hat\chi}{b}\right\rfloor$. After the (exact) division of $\dfrac{\chi - \hat\chi}{b}$, we directly replace the modulus $qb$ with $q$. This direct replacement of modulus is arithmetically allowed because the computation result of $\dfrac{\chi - \hat{\chi}}{b}$ is guaranteed to be within $-\dfrac{q}{2}$ and $\dfrac{q}{2} -1$ (since $-\dfrac{qb}{2}\leq \chi \leq \dfrac{qb}{2}-1$). Therefore, we can derive the following formula:

$\dfrac{\chi - \hat{\chi}}{b} \bmod q = |b^{-1}|_{q}\cdot (\chi - \hat{\chi}) \bmod q$  %\textcolor{red}{ \# since $\chi - \hat\chi$ is divisible by $b$, and $b$ has an inverse in $\mathbb{Z}_q$}

$ $

In the above relation, we can arithmetically replace $b$ with $|b^{-1}|_q$, because $\chi - \hat{\chi}$ is divisible by $b$ and $b$ is guaranteed to have an inverse modulo $q$ (since $b$ and $q$ are co-prime). Next, we can compute  $|b^{-1}|_{q}\cdot (\chi - \hat{\chi}) \bmod q$ based on their RNS residues as follows:

$|b^{-1}|_q\cdot (\chi - \hat{\chi}) \bmod q$

$= \bm(|b^{-1}|_{q_1} \cdot (\chi_1 - \hat\chi_1), \text{ } |b^{-1}|_{q_2} \cdot (\chi_2 - \hat\chi_2), \text{ } \cdots, \text{ } |b^{-1}|_{q_k} \cdot (\chi_k - \hat\chi_k)\bm) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} $

$= (y_1, y_2, \cdots, y_k) $ \textcolor{red}{ \# where each $y_i = |b^{-1}|_{q_i} \cdot (\chi_i - \hat\chi_i) \bmod q_i$}

$ $

Now, our task is to derive an expression for some small $\hat\chi$ such that $\chi - \hat\chi$ is divisible by $b$. We propose that $\hat\chi = |\chi|_b + ub$ for some small integer $|u| \leq \dfrac{l}{2}+1$. Then, notice that $\chi - \hat\chi$ is divisible by $b$ as follows:

$|\chi - \hat\chi|_b = \Big||\chi|_b - (|\chi|_b + ub)\Big|_b = |-ub|_b = 0$


$ $

Now, we will derive the RNS vector of $\hat\chi \bmod q = |\chi|_b + ub \bmod q$, which is to be plugged into $|b^{-1}|_q\cdot (\chi - \hat{\chi}) \bmod q$. First, we derive the RNS vector of $|\chi|_{b}$ as follows: 

$(|\chi|_{b_1}, |\chi|_{b_2}, \cdots, |\chi|_{b_l}) = (\chi_{k+1}, \chi_{k+2}, \cdots, \chi_{k+l}) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$



$ $

Next, we can compute its fast base conversion from $b \rightarrow q$ as follows:

$\textsf{FastBConv}(\{\chi_{k+i}\}_{i=1}^{l}, b, q)$

$= (\hat\chi_1, \hat\chi_2, \cdots, \hat\chi_{k}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$

$ $ 

Now, notice that the above RNS residue vector $(\hat\chi_1, \hat\chi_2, \cdots, \hat\chi_k)$ represents the value $\hat\chi = |\chi|_b + u \cdot b \bmod q$ (where integer $|u| \leq \dfrac{l}{2}+1$), which is our desired formula for $\hat\chi$. Therefore, $\hat\chi = \textsf{FastBConv}(\{\chi_{k+i}\}_{i=1}^{l}, b, q)$.

Note that $\hat\chi \ll \dfrac{q}{2}-1$ and $-\dfrac{q}{2} \ll \hat\chi$, because $\Big||\chi|_b + u\cdot b\Big| < \left(\dfrac{l}{2} + 1\right)\cdot b + \dfrac{b}{2} \ll \dfrac{q}{2}$ (here we assume that $b \ll q$, as we assume the modulus switch operation is used to remove only a single prime factor from the large base $q$). Therefore, the magnitude of the error generated by computing $ b^{-1} \cdot (\chi - \hat\chi)$ is approximately $\left\lceil\dfrac{\hat\chi}{b}\right\rfloor <  \left\lceil\dfrac{\left(\dfrac{l}{2} + 1\right)\cdot b + \dfrac{b}{2}}{b}\right\rfloor = \left\lceil\dfrac{lb + 3b}{2b}\right\rfloor = \left\lceil\dfrac{l + 3}{2}\right\rfloor < \dfrac{l}{2} + 2$. 

%the relationship between $\$

$ $

We summarize the \textsf{ModSwitch\textsubscript{RNS}} operation as follows:


\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsec:rns-modswitch}} \textsf{ModSwitch\textsubscript{RNS}}}}]


\textbf{\underline{Input}:} $(\chi_1, \chi_2, \cdots, \chi_{k+l}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l} $ 

\textcolor{red}{ \# which represents $\chi = \left(\sum\limits_{i=1}^{k}\left|\chi_i\cdot\left(\dfrac{qb}{q_i}\right)^{-1}\right|_{q_i}\cdot\dfrac{qb}{q_i}\right) + \left(\sum\limits_{j=k+1}^{k+l}\left|\chi_j\cdot\left(\dfrac{qb}{b_j}\right)^{-1}\right|_{b_j}\cdot\dfrac{qb}{b_j}\right) \bmod qb$} 

$ $

\textbf{\underline{Notations}}

\begin{itemize}

\item The RNS vector $(\chi_{1}, \chi_{2}, \cdots, \chi_{k}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ represents the value: $|\chi|_q \in \mathbb{Z}_q$

\item $\textsf{FastBConv}(\{\chi_{k+1}\}_{i=1}^{l}, b, q) = (\hat{\chi}_1, \hat{\chi}_2, \cdots, \hat{\chi}_k) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ 

, which represents the value $\hat{\chi} = |\chi|_b + ub \in \mathbb{Z}_q$ \textcolor{red}{ \# where $|u| \leq \dfrac{l}{2}+1$}

\end{itemize}

$ $


\textbf{\underline{Main Steps}}


$\textsf{ModSwitch\textsubscript{RNS}}(\{\chi_i\}_{i=1}^{k+l}, qb, q)$


$= \{|b^{-1}|_{q_i}\cdot (\chi_i - \hat{\chi}_i) \bmod q_i\}_{i=1}^{k} \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ 

$ $

, whose RNS residue vector represents the value $|b^{-1}|_{q} \cdot (\chi - \hat{\chi}) \bmod q$. The magnitude of noise generated by \textsf{ModSwitch\textsubscript{RNS}} is roughly $\left\lceil\dfrac{\hat{\chi}}{b}\right\rfloor < \dfrac{l}{2} + 2$.

\end{tcolorbox}

\subsubsection{Comparing \textsf{ModSwitch\textsubscript{RNS}}, \textsf{ModRaise\textsubscript{RNS}}, and \textsf{ModDrop\textsubscript{RNS}}}

Given a big value $x \in \mathbb{Z}_q$ in an RNS vector, \textsf{ModSwitch\textsubscript{RNS}} reduces its modulus from $q \rightarrow  q'$ as well as explicitly decreases the modulo value $x$ by the proportion of $\dfrac{q'}{q}$ (i.e., updates $x$ to $ \left\lceil x \cdot \dfrac{q'}{q}\right\rfloor$). On the other hand, \textsf{ModDrop\textsubscript{RNS}} from $q \rightarrow q'$ updates the modulo value from $x \rightarrow |x|_{q'}$ (where $q'$ divides $q$), which is different from decreasing $x$ by the proportion of $\dfrac{q'}{q}$ like modulus switch. \textsf{ModRaise\textsubscript{RNS}} from $q \rightarrow qb$ (where $q$ divides $qb$) increases the modulus without explicitly modifying the modulo value $x$, but generates some $q$-overflow noise. \textsf{ModSwitch\textsubscript{RNS}} and \textsf{ModRaise\textsubscript{RNS}} generate some noise, whereas \textsf{ModDrop\textsubscript{RNS}} does not generate any noise. %All these 3 types of operations introduce some level of additional noise (or decrease the noise budget), which has to be handled during decryption. 




\subsection{RNS-based Decryption}
\label{subsec:rns-dec}

This subsection will explain how to efficiently decrypt RNS-based ciphertexts for BFV, CKKS, and BGV. 


\subsubsection{BFV Decryption: $\textsf{Dec}_{\textsf{RNS}}^{\textsf{BFV}}$}
\label{subsubsec:rns-dec-bfv}

Suppose we have a BFV ciphertext $(A, B)$ such that $B = A\cdot S + \Delta M + E$ (where $\Delta = \left\lfloor\dfrac{q}{t}\right\rfloor$). We decrypt the ciphertext as follows: $M = \left\lceil\dfrac{B - A\cdot S}{\Delta}\right\rfloor$ (Summary~\ref*{subsec:bfv-enc-dec} in \autoref{subsec:bfv-enc-dec}). However, RNS does not allow direct division and rounding. Therefore, we need to express this divide-and-round operation in terms of addition and multiplication.

Let's denote $\textsf{ct}(s) = \Delta m + e + kq$ (i.e., a decryption of ciphertext $\textsf{ct}$ without modulo-$q$ reduction). In this description, we will consider only a single set of coefficients $m$, $e$, and $k$ extracted from polynomials $M$, $E$, and $K$ for simplicity. 

As explained in \autoref{subsec:modulo-division}, modulo arithmetic does not support direct division. Meanwhile, the special relation $\dfrac{a}{b} \bmod p = a \cdot b^{-1} \bmod p$ holds if $b$ divides $a$ and an inverse of $b$ modulo $p$ exists (i.e., $b$ and $p$ are co-prime). Inspired by this, we can express the decrypted plaintext $m$ as follows: 

$m = \left\lceil\dfrac{|\textsf{ct}(s)|_q}{\Delta}\right\rfloor = \left\lfloor\dfrac{|\textsf{ct}(s)|_q}{\Delta}\right\rfloor + e_r$ \textcolor{red}{ \# where $e_r \in [0, 1]$ is a rounding error}

$ = \left\lfloor |\textsf{ct}(s)|_q\cdot \dfrac{t}{q} \right\rfloor + e_r + e_d$  \textcolor{red}{ \# where $e_d = \left\lfloor\dfrac{|\textsf{ct}(s)|_q}{\Delta}\right\rfloor - \left\lfloor |\textsf{ct}(s)|_q\cdot \dfrac{t}{q} \right\rfloor$ is a scaling error} 

$= \left\lfloor\dfrac{t\cdot |\textsf{ct}(s)|_q}{q}\right\rfloor + e_r + e_d$ 

$= \dfrac{t\cdot |\textsf{ct}(s)|_q - |t\cdot \textsf{ct}(s)|_q}{q} + e_r + e_d$ \textcolor{red}{ \# where $|t\cdot \textsf{ct}(s)|_q \equiv t\cdot |\textsf{ct}(s)|_q \bmod q$, and therefore $t\cdot |\textsf{ct}(s)|_q - |t\cdot \textsf{ct}(s)|_q$ is divisible by $q$}

$ $

%The final step of decryption is applying modulo reduction $t$ to $M$: $|M|_t$. Applying modulo reduction $t$ to the above relation is equal to the following: 

%$|m|_t = \left|\dfrac{t\cdot |\textsf{ct}(s)|_q - |t\cdot \textsf{ct}(s)|_q}{q} + e_r + e_d\right|_t$

%$= \left|\dfrac{t\cdot |\textsf{ct}(s)|_q - |t\cdot \textsf{ct}(s)|_q}{q}\right|_t + |e_r|_t + |e_d|_t$

%$= \left|\dfrac{t\cdot |\textsf{ct}(s)|_q - |t\cdot \textsf{ct}(s)|_q}{q}\right|_t + e_r + e_d$ \textcolor{red}{ \# assuming $e_r$ and $e_d$ are small enough not to cause any $t$-overflow}

%$= \left|(t\cdot |\textsf{ct}(s)|_q - |t\cdot \textsf{ct}(s)|_q)\cdot q^{-1}\right|_t + e_r + e_d$ \textcolor{red}{ \# since $q$ divides $t\cdot |\textsf{ct}(s)|_q - |t\cdot \textsf{ct}(s)|_q$}

%$= \left|- |t\cdot \textsf{ct}(s)|_q\cdot q^{-1}\right|_t + e_r + e_d$ \textcolor{red}{ \# since $t\cdot |\textsf{ct}(s)|_q$ is a multiple of $t$}

%$= ||t\cdot \textsf{ct}(s)|_q|_t \cdot |-q^{-1}|_t + e_r + e_d$

%$= \bm(\textsf{FastBConv}(t\cdot \textsf{ct}(s), q, t) - uq\bm) \cdot |-q^{-1}|_t + e_r + e_d$ \textcolor{red}{ \# note that the fast base conversion of $t\cdot \textsf{ct}(s)$ from $q\rightarrow t$ is $\textsf{FastBConv}(t\cdot \textsf{ct}(s), q, t) = t\cdot \textsf{ct}(s) + uq \bmod t$, where integer $|u| \leq \dfrac{l}{2}+1$ and the original base moduli are ${q_1, q_2, \cdots, q_l}$.}

%$ $

%$= \textsf{FastBConv}(t\cdot \textsf{ct}(s), q, t) \cdot |-q^{-1}|_t + e_r + e_d + u$


%$ $

%However, now the problem is that while we can compute the $\textsf{FastBConv}(t\cdot \textsf{ct}(s), q, t)$ term, we don't know what values the noises $e_r$, $e_d$, and $u$ are unless we manually (i.e., slowly) compute for them. Without knowing $e_r$, $e_d$, and $u$, we cannot compute $|m|_t$. Manually computing $e_r$, $e_d$, and $u$ ruins the point of using fast base conversion. To this end, our next task is to efficiently (not manually) compute $e_r + e_d + u$. 

%To solve this problem, let's suppose we tentatively change our goal from computing $|m|_t$ to computing $|\gamma \cdot m|_t$ where $\gamma$ is a small co-prime to $q$. Then, we derive the expression for $\gamma \cdot m$ as follows:

Now, we choose some prime number $\gamma$ which is co-prime to $t$ and $q$. Then, we derive the expression for $\gamma \cdot m$ as follows:

$\gamma \cdot m =  \gamma\cdot \left\lceil\dfrac{ |\textsf{ct}(s)|_q}{\Delta}\right\rfloor$

$ = \left\lceil\dfrac{\gamma\cdot |\textsf{ct}(s)|_q}{\Delta}\right\rfloor + e'_s $ \textcolor{red}{ \# where $e'_s = \gamma\cdot \left\lceil\dfrac{ |\textsf{ct}(s)|_q}{\Delta}\right\rfloor - \left\lceil\dfrac{\gamma\cdot |\textsf{ct}(s)|_q}{\Delta}\right\rfloor$ is a multiplication error}

$ =  \left\lfloor\dfrac{\gamma \cdot |\textsf{ct}(s)|_q}{\Delta}\right\rfloor + e'_s + e'_r$ \textcolor{red}{ \# where $e'_r \in [0, 1]$ is a rounding error}

$ =  \left\lfloor\gamma \cdot | \textsf{ct}(s)|_q\cdot \dfrac{t}{q} \right\rfloor + e'_s + e'_r + e'_d$  \textcolor{red}{ \# where $e'_d =  \left(\left\lfloor\dfrac{\gamma \cdot |\textsf{ct}(s)|_q}{\Delta}\right\rfloor - \left\lfloor \gamma \cdot |\textsf{ct}(s)|_q\cdot \dfrac{t}{q} \right\rfloor\right)$ is a scaling error} 

$=  \left\lfloor\dfrac{\gamma \cdot t\cdot |\textsf{ct}(s)|_q}{q}\right\rfloor + e'_s + e'_r + e'_d$ 

$= \dfrac{\gamma \cdot t\cdot |\textsf{ct}(s)|_q -  |\gamma \cdot t\cdot \textsf{ct}(s)|_q}{q} + e'_s + e'_r + e'_d$ 

$ $

Next, we derive the expression for $|\gamma \cdot m|_{\gamma t}$ as follows:

$|\gamma \cdot m|_{\gamma t} = \left|\dfrac{\gamma\cdot t\cdot |\textsf{ct}(s)|_q - |\gamma\cdot t\cdot \textsf{ct}(s)|_q}{q} + e'_s + e'_r + e'_d\right|_{\gamma t}$

$= \left|\dfrac{\gamma\cdot t\cdot |\textsf{ct}(s)|_q -  |\gamma\cdot t\cdot \textsf{ct}(s)|_q}{q}\right|_{\gamma t} + |e'_s|_{\gamma t} + |e'_r|_{\gamma t} + |e'_d|_{\gamma t}$

$= \left|\dfrac{\gamma\cdot t\cdot |\textsf{ct}(s)|_q -  |\gamma\cdot t\cdot \textsf{ct}(s)|_q}{q}\right|_{\gamma t} + e'_s + e'_r + e'_d$ \textcolor{red}{ \# assuming $|e'_s| \ll \dfrac{\gamma t}{2}$ and $|e'_r| \ll \dfrac{\gamma t}{2}$ and $|e'_d| \ll \dfrac{\gamma t}{2}$}

$= \Big|(\gamma\cdot t\cdot |\textsf{ct}(s)|_q -  |\gamma\cdot t\cdot \textsf{ct}(s)|_q)\cdot q^{-1}\Big|_{\gamma t} + e'_s + e'_r + e'_d$  \textcolor{red}{ \# since $\gamma\cdot t\cdot |\textsf{ct}(s)|_q - |\gamma\cdot t\cdot \textsf{ct}(s)|_q$ is divisible by $q$, and $q$ is co-prime to $\gamma t$}

$ $

$= \left|-  |\gamma\cdot t\cdot \textsf{ct}(s)|_q\cdot q^{-1}\right|_{\gamma t} + e'_s + e'_r + e'_d$ \textcolor{red}{ \# since $\gamma \cdot t\cdot |\textsf{ct}(s)|_q$ is a multiple of $\gamma t$}

$= \Big||\gamma\cdot t\cdot \textsf{ct}(s)|_q\Big|_{\gamma t} \cdot |-q^{-1}|_{\gamma t} + e'_s + e'_r + e'_d$

%$= \bm(\textsf{FastBConv}(\gamma\cdot t\cdot \textsf{ct}(s), q, \{t,\gamma \}) - u'q\bm) \cdot |-q^{-1}|_{\gamma t} + e'_r + e'_d$ \textcolor{red}{ \# note that the fast base conversion of $\gamma\cdot t\cdot \textsf{ct}(s)$ from $q\rightarrow t\cdot \gamma$ is $\textsf{FastBConv}(\gamma\cdot t\cdot \textsf{ct}(s), q, \{t, \gamma\}) = \gamma\cdot t\cdot \textsf{ct}(s) + u'q \bmod \gamma t$, where $|u'| \leq \dfrac{l}{2}+1$ and the original base moduli are ${q_1, q_2, \cdots, q_l}$.}

%$ $

%$= \textsf{FastBConv}(\gamma\cdot t\cdot \textsf{ct}(s), q, \{t,\gamma \}) \cdot |-q^{-1}|_{\gamma t} + e'_r + e'_d + u'$

$ $

Given the above relation, notice that the computation result of $\textsf{FastBConv}\bm(\gamma\cdot t\cdot \textsf{ct}(s), q, \gamma t\bm) \cdot |-q^{-1}|_{\gamma t}$ can be expressed as follows: 

$\textsf{FastBConv}\bm(\gamma\cdot t\cdot \textsf{ct}(s), q, \gamma t\bm) \cdot |-q^{-1}|_{\gamma t}$

$ = \Big||\gamma t \cdot \textsf{ct}(s)|_q + uq\Big|_{\gamma t} \cdot |-q^{-1}|_{\gamma t} $ \textcolor{red}{\# where $|u| \leq \dfrac{k}{2}+1$ for the base moduli $q_1, q_2, \cdots, q_k$}

$ =  \Big||\gamma t \cdot \textsf{ct}(s)|_q \cdot |-q^{-1}|_{\gamma t}  - u\Big|_{\gamma t}$

$= |\gamma \cdot m|_{\gamma t}  - e'_s - e'_r - e'_d - u$ \textcolor{red}{ \# as we previously showed that $|\gamma \cdot m|_{\gamma t} = \Big||\gamma\cdot t\cdot \textsf{ct}(s)|_q\Big|_{\gamma t} \cdot |-q^{-1}|_{\gamma t} +  + e'_s + e'_r + e'_d$}

$= y$ \textcolor{red}{ \# let's denote the above expression as $y$}

$ $

Then, if $e'_s, e'_r, e'_d, u$ are small enough such that $|e'_s + e'_r + e'_d + u| < \gamma$, then $|y|_{\gamma} = -e'_s -e'_r - e'_d - u$ (as $|\gamma \cdot m|_{\gamma t} \bmod \gamma = 0$ as a multiple of $\gamma$). Therefore, we can effectively remove the noise terms $e'_s, e'_r, e'_d, u$ and derive $m$ as follows:

$\bm{\Big|}(y - |y|_{\gamma}) \cdot |\gamma^{-1}|_t\bm{\Big|}_t$

$ = \bm{\Big|}|\gamma\cdot m|_{\gamma t} \cdot |\gamma^{-1}|_t\bm{\Big|}_t$

$ = \bm{\Big|}|\gamma\cdot m|_{t} \cdot |\gamma^{-1}|_t\bm{\Big|}_t$ \textcolor{red}{ \# since $\Big||\gamma\cdot m|_{\gamma t}\Big|_t = |\gamma\cdot m|_{t}$}

$= |m|_t$

$ $

, which is the final decryption of \textsf{ct} we wanted to compute. Let's denote the RNS vector of $y$ as a $(y_{\gamma}, y_{t}) \in \mathbb{Z}_{\gamma} \times \mathbb{Z}_{t}$. Then, we can efficiently compute the term $\Big|(y - |y|_{\gamma}) \cdot |\gamma^{-1}|_t\Big|_t$ as follows:

$\Big|(y - |y|_{\gamma}) \cdot |\gamma^{-1}|_t\Big|_t$

$= \Bigg|\Big( \overbrace{\Big|y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma} + y_{t}\cdot \gamma \cdot |\gamma^{-1}|_{t} \Big|_{\gamma t}}^{y} - \overbrace{\Big|y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma} + y_{t}\cdot \gamma \cdot |\gamma^{-1}|_{t}\Big|_{\gamma}}^{|y|_{\gamma}}\Big) \cdot |\gamma^{-1}|_t\Bigg|_t$

$= \Bigg|\Big( \overbrace{\Big|y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma} + y_{t}\cdot \gamma \cdot |\gamma^{-1}|_{t} \Big|_{t}}^{y} - \overbrace{\Big|y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma} + y_{t}\cdot \gamma \cdot |\gamma^{-1}|_{t}\Big|_{\gamma}}^{|y|_{\gamma}}\Big) \cdot |\gamma^{-1}|_t\Bigg|_t$ \textcolor{red}{ \# since $\Big||y|_{\gamma t}\Big|_t = |y|_t$}


$= \Bigg|\Big( \overbrace{\Big|y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma} + y_{t}\cdot \gamma \cdot |\gamma^{-1}|_{t} \Big|_t}^{y} - \overbrace{\Big|y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma}\Big|_{\gamma}}^{|y|_{\gamma}}\Big) \cdot |\gamma^{-1}|_t\Bigg|_t$ \textcolor{red}{ \# since $y_{t}\cdot \gamma \cdot |\gamma^{-1}|_{t} \bmod \gamma = 0$}

$= \Bigg|\Big( \overbrace{\Big|y_{t}\cdot \gamma \cdot |\gamma^{-1}|_{t}\Big|_t}^{y} - \overbrace{\Big|y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma}\Big|_{\gamma}}^{|y|_{\gamma}}\Big) \cdot |\gamma^{-1}|_t\Bigg|_t$ \textcolor{red}{ \# since $y_{\gamma}\cdot t \cdot |t^{-1}|_{\gamma} \bmod t = 0$}

$= \Big|(y_t - y_{\gamma}) \cdot |\gamma^{-1}|_t\Big|_t$ \textcolor{red}{ \# since $|\gamma \cdot \gamma^{-1}|_t = 1$ and $|t \cdot t^{-1}|_{\gamma} = 1$}

$ $

We summarize $\textsf{Dec}_{\textsf{RNS}}^{\textsf{BFV}}$ as follows:

\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsubsec:rns-dec-bfv}} $\textsf{Dec}_{\textsf{RNS}}^{\textsf{BFV}}$}}]


\textbf{\underline{Input}:} $\textsf{ct}(s) = \Delta m + e + kq$

\begin{enumerate}
\item Pick some prime number $\gamma$ which is co-prime to $t$ and $q$.

\item Compute $\textsf{FastBConv}(|\gamma \cdot t \cdot \textsf{ct}(s)|_q, q, \gamma t) \cdot |-q^{-1}|_{\gamma t}$

$ = (y_{\gamma}, y_{t}) \in \mathbb{Z}_{\gamma} \times \mathbb{Z}_{t}$

\item Compute $|m|_t = \Big|(y_{t} - y_{\gamma})\cdot |\gamma^{-1}|_t\Big|_t$

\end{enumerate}

\end{tcolorbox}


\begin{comment}
\subsection{RNS-based CKKS Decryption: $\textsf{Dec}_{\textsf{RNS}}^{\textsf{CKKS}}$}
\label{subsec:rns-ckksdec}

RNS-based decryption of CKKS ciphertexts is similar to that of BFV ciphertexts. CKKS's decryption formula is 
\end{comment}

\subsubsection{CKKS and BGV Decryption}
\label{subsubsec:rns-dec-ckks-bgv}

CKKS and BGV ciphertexts can be decrypted efficiently by performing the \textsf{ModDrop} operation (Summary~\ref*{subsec:rns-moddrop} in \autoref{subsec:rns-moddrop}) to the lowest multiplicative level. After this, there remains only a single ciphertext modulus in the RNS base, so the regular decryption algorithm can be executed efficiently without any RNS components. 



\subsection{BGV's RNS-based Modulus Switch: $\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$}
\label{subsec:rns-modswitch-bgv}

BGV's RNS-based modulus switch is not computed by \textsf{ModSwitch\textsubscript{RNS}}, because BGV's original non-RNS modulus switch (Summary~\ref*{subsec:bgv-modulus-switch} in \autoref{subsec:bgv-modulus-switch}) is performed in a different manner than BFV or CKKS's non-RNS modulus switch (Summary~\ref*{subsec:modulus-switch-rlwe} in \autoref{subsec:modulus-switch-rlwe}). BGV's non-RNS modulus switch is computed as follows: 

$(A', B') = \left(\left\lceil\dfrac{\hat{q}}{q_l} A\right\rfloor, \left\lceil\dfrac{\hat{q}}{q_l}\cdot B\right\rfloor\right) \in \mathcal{R}_{\langle n, \hat{q} \rangle}^2$

$ $

$\epsilon'_A = \hat{q}\cdot A - q_l\cdot A'$ \textcolor{red}{ \# where $\epsilon'_A \in \mathbb{Z}_{q_l}$}

$\epsilon'_B = \hat{q}\cdot B - q_l\cdot B'$ \textcolor{red}{ \# where $\epsilon'_B \in \mathbb{Z}_{q_l}$}


$ $

$H_A = q_l^{-1}\cdot\epsilon'_A \bmod t$

$H_B = q_l^{-1}\cdot\epsilon'_B \bmod t$

$ $

$\hat{\textsf{ct}} = (\hat{A}, \hat{B}) = (A' + H_A, B' + H_B) \bmod \hat{q}$


$ $


Therefore, BGV's RNS-based modulus switch only needs to compute the above formulas for $\hat{A}$ and $\hat{B}$ based on RNS's $(+, \cdot)$ arithmetic. In the above computations, the only part that cannot be directly computed by RNS-based $(+, \cdot)$ operations is the rounding in $\left\lceil\dfrac{\hat{q}}{q_l} A\right\rfloor$ and $\left\lceil\dfrac{\hat{q}}{q_l}\cdot B\right\rfloor$. This rounding can be performed in RNS by using $\textsf{Dec}_{\textsf{RNS}}^{\textsf{BFV}}$, by setting $q = q_l$ and $t = \hat{q}$. 


\subsection{Small Montgomery Reduction Algorithm: \textsf{SmallMont}}
\label{subsec:rns-smallmont}

One problem of the \textsf{FastBConv} (i.e., the fast base conversion) operation is that it creates a non-negligible noise. Specifically, suppose we use \textsf{FastBConv} to convert the base of $x \in \mathbb{Z}_q$ (where $q = q_1 \cdot q_2 \cdot \cdots \cdot q_k$ moduli) into $c = x + uq \bmod b$ (where $b = b_1 \cdot b_2 \cdot \cdots \cdot b_l$ moduli),  where integer $|u| \leq \dfrac{k}{2}+1$. Then, the noise generated by this conversion is between $-\left(\dfrac{k}{2}+1\right)\cdot q \bmod b$ and $\left(\dfrac{k}{2}+1\right)\cdot q \bmod b$. To reduce this noise, we will explain the small Montgomery algorithm (\textsf{SmallMont}) which reduces the noise generated by fast base conversion from $uq$ to $u'q$, such that $u' \in \{-1, 0, 1\}$. The small Montgomery algorithm is designed as follows:

\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsec:rns-smallmont}} Fast Modulo Reduction: \textsf{SmallMont}}}]


\textbf{\underline{Input}:} $c = (c_1, c_2, \cdots, c_l, c_{l+1}) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l} \times \mathbb{Z}_{b_\alpha}$ \textcolor{red}{ \# $b_\alpha$ is a prime and co-prime to $b$, where $b = \prod\limits_{i=1}^lb_i$}

$ $

, where $c = \textsf{FastBConv}\bm(|b_\alpha \cdot x|_q, q, bb_\alpha\bm) = |b_\alpha \cdot x|_q + uq$ \textcolor{red}{ \# where $x \in \mathbb{Z}_q$ and integer $|u| \leq \dfrac{k}{2}+1$}

$ $

\textbf{\underline{Main Steps}}

\textbf{$\textsf{SmallMont}(c, bb_\alpha, b_\alpha, q): $} 

\begin{enumerate}
\item $c' = |c \cdot q^{-1}|_{b_\alpha}$
\item For each $i \in [1, l]$, compute $r_i = \Big|(c_{b_i} - |q|_{b_i}\cdot c') \cdot b_\alpha^{-1} \Big|_{b_i}$
\end{enumerate}

$ $

\textbf{\underline{Output:}} $r = (\overbrace{r_1, r_2, \cdots, r_l}^{l}) \in \overbrace{\mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}}^{l}$ \textcolor{red}{ \# without $r_\alpha \in \mathbb{Z}_{b_\alpha}$}

$ $

The output satisfies the relation: $r = x + u'q \bmod b$ (where $u' \in \{-1, 0, 1\}$)

\end{tcolorbox}

\begin{myproof}

\begin{enumerate}
\item Given $c' = |c \cdot q^{-1}|_{b_\alpha}$, notice that $c - q \cdot c'$ is exactly divisible by $b_\alpha$ as shown below: 

$c - q \cdot c' \bmod b_\alpha$

$= c - q \cdot |c \cdot q^{-1}|_{b_\alpha} \bmod b_\alpha$ \textcolor{red}{ \# substituting $c' = |c \cdot q^{-1}|_{b_\alpha}$}

$= c - c \bmod b_\alpha$ \textcolor{red}{ \# by canceling out $|q|_{b_\alpha}$ and $|q|^{-1}_{b_\alpha}$}

$= 0 \bmod b_\alpha$

$ $

Since $c - q \cdot c' = 0 \bmod b_\alpha$, this implies that $c - q \cdot c'$ is a multiple of $b_\alpha$ (i.e., $c - q \cdot c'$ is exactly divisible by $b_\alpha$). This also implies that $\dfrac{c - q \cdot c'}{b_\alpha}$ is an integer. 

$ $

\item Given $c = |b_\alpha \cdot x|_q + uq \bmod b$ and $c' = |c \cdot q^{-1}|_{b_\alpha}$, we can express $\dfrac{c - q \cdot c'}{b_\alpha} \bmod b$ as follows:

%%%$\left|\dfrac{c - q \cdot c'}{b_\alpha}\right|_{bb_\alpha} = \left|\dfrac{c - q \cdot c'}{b_\alpha}\right|_{b}$ \textcolor{red}{ \# since $c < bb_\alpha$, it is guaranteed that $\dfrac{c - q \cdot c'}{b_\alpha} < b$}
$\left|\dfrac{c - q \cdot c'}{b_\alpha}\right|_{b}$


$ = \left|\dfrac{c - q \cdot |c \cdot q^{-1}|_{b_\alpha}}{b_\alpha}\right|_{b}$ \textcolor{red}{ \# by substituting $c' = |c \cdot q^{-1}|_{b_\alpha}$}


$ = \left|\dfrac{|b_\alpha \cdot x|_q + uq - q \cdot \Bigg|\Big||b_\alpha \cdot x|_q + uq\Big|_{b} \cdot q^{-1}\Bigg|_{b_\alpha}}{b_\alpha}\right|_{b}$ \textcolor{red}{ \# by substituting $c = \Big||b_\alpha \cdot x|_q + uq\Big|_{b}$}


$ = \Bigg|\dfrac{b_\alpha\cdot x + vq + uq - q \cdot \Big||b_\alpha\cdot x + vq + uq|_{b} \cdot q^{-1}\Big|_{b_\alpha}}{b_\alpha}\Bigg|_{b}$ \textcolor{red}{ \# by rewriting $|b_\alpha\cdot x|_{q}$ as $b_\alpha\cdot x + vq$ (where $v$ is some integer representing the $q$-overflows of $b_\alpha\cdot x$)}

$ $

$ = \Bigg|x + \dfrac{vq + uq - q \cdot \Big||b_\alpha\cdot x + vq + uq|_{b} \cdot q^{-1}\Big|_{b_\alpha}}{b_\alpha}\Bigg|_{b}$ \textcolor{red}{ \# since $x = \dfrac{b_\alpha \cdot x}{b_\alpha}$}

$ = \Bigg|x + q\cdot \dfrac{v + u - \Big||b_\alpha\cdot x + vq + uq|_{b} \cdot q^{-1}\Big|_{b_\alpha}}{b_\alpha}\Bigg|_{b}$ \textcolor{red}{ \# taking out the common multiple $q$}



$ $

The above computation result is guaranteed to be an integer (as we proved in the proof step 1). And $q$ and $b_\alpha$ are co-prime (by the input definition). This leads to the conclusion that 

$ \dfrac{v + u - \Big||b_\alpha\cdot + vq + uq|_{b} \cdot q^{-1}\Big|_{b_\alpha}}{b_\alpha}$ is guaranteed to be an integer. Therefore, if we choose $b_\alpha$ (i.e., a prime and co-prime to both $q$ and $b$) as a sufficiently large value, then $ \dfrac{v + u - \Big||b_\alpha\cdot x + vq + uq|_{b} \cdot q^{-1}\Big|_{b_\alpha}}{b_\alpha}$ will converge to $\{-1, 0, 1\}$. This is because as $b_\alpha$ increases: (1) $v$ grows slower than $b_\alpha$ (since $|b_\alpha\cdot x|_q = b_\alpha\cdot x + vq$); (2) the magnitude of $u$ stays smaller than $\dfrac{k}{2} + 1$ (as integer $|u| \leq \dfrac{k}{2}+1$); and (3) $\Big||b_\alpha\cdot x + vq + uq|_{b} \cdot q^{-1}\Big|_{b_\alpha}$ is guaranteed to be an integer between $\left[-\dfrac{b_\alpha+1}{2}, \dfrac{b_\alpha}{2} - 1\right]$. In conclusion, if $b_\alpha$ is sufficiently large, then we get the following relation: 

$\left|\dfrac{c - q\cdot c'}{b_\alpha}\right|_{b} = x + u'q \bmod b$ \textcolor{red}{ \# where $u' \in \{-1, 0, 1\}$}

$ $

Also, the following is true: 

$\dfrac{c - q\cdot c'}{b_\alpha} \bmod b = (c - q\cdot c')\cdot b_\alpha^{-1} \bmod b$ \textcolor{red}{ \# because $b_\alpha$ divides $c - q\cdot c'$ and $b_\alpha$ is co-prime to $b$} 

$ $

\item It is possible to express the final output $x + u'q \bmod b$ as an RNS vector with the residues of the base moduli $(b_1, \cdots, b_l)$. For this, we convert $(c - q\cdot c')\cdot b_\alpha^{-1}$ into the RNS vector $(r_1, r_2, \cdots, r_l) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$ by computing the following for each $i \in [1, l]$:

$r_i = |(c - q\cdot c')\cdot b_\alpha^{-1}|_{b_i}$

$ = |(c_{b_i} - |q|_{b_i}\cdot c') \cdot b_\alpha^{-1} |_{b_i}$


\end{enumerate}
\end{myproof}

\subsubsection{Improving \textsf{FastBConv} by Using \textsf{SmallMont}}
\label{subsubsec:rns-smallmont-fastbconv}

Notice that by using \textsf{SmallMont} in Summary~\ref*{subsec:rns-smallmont}, the accuracy of the raw output of $\textsf{FastBConv}(x, q, b) = |x + uq|_b$ (where integer $|u| \leq \dfrac{k}{2}+1$) is improved to $|x + u'q|_b$ (where $u' \in \{-1, 0, 1\}$) as follows:

$\textsf{SmallMont}\bm(\textsf{FastBConv}\bm(|b_\alpha \cdot x|_q, q, bb_\alpha\bm), bb_\alpha, b_\alpha, q\bm) $

$\textsf{SmallMont}\bm(\Big||b_\alpha \cdot x|_q + uq\Big|_{bb_\alpha}, bb_\alpha, b_\alpha, q\bm) $


$= |x + u'q|_b$ \textcolor{red}{ \# where $u' \in \{-1, 0, 1\}$}

$ $



\subsection{Exact Fast Base Conversion: \textsf{FastBConvEx}}
\label{subsec:rns-fastbconvex}

\textsf{FastBConv} (\autoref{subsec:rns-fastbconv}) converts an input value $x$'s base moduli from $q \rightarrow b$, but generates a noise equivalent to $uq \bmod b$ where integer $|u| \leq \dfrac{k}{2}+1$. If we use \textsf{FastBConv} with \textsf{SmallMont} (\autoref{subsec:rns-smallmont}), we can reduce the generated noise from $uq$ to $u'q$ where $u' \in \{-1, 0, 1\}$. In this subsection, we introduce \textsf{FastBConvEx}, an algorithm for an exact fast base conversion that can eliminate the entire noise. However, using \textsf{FastBConvEx} has a restriction that the input value $x$ should be relatively much smaller than its modulus. This is different from the case of using \textsf{FastBConv} with \textsf{SmallMont} which has no restriction on the input $x$ (i.e., $x$ can be any value within its modulus range). \textsf{FastBConvEx} is designed as follows:

\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsec:rns-fastbconvex}} Fast Exact Base Conversion: \textsf{FastBConvEx}}}]

\textbf{\underline{Input}:} $x = (x_1, x_2, \cdots, x_l, x_\alpha) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l} \times \mathbb{Z}_{b_\alpha}$ 

$ $

\textbf{\underline{Requirement}: } The size of $b_\alpha$ should be $b_{\alpha} \geq 2\cdot(l + \lambda)$, where $|x|_{b} = x + \mu \cdot b$, and $\mu \in [-\lambda, \lambda]$ (i.e., $\lambda$ and $-\lambda$ are the maximum and minimum possible values of $\mu$). 

\textcolor{red}{ \# The constraint that $b_\alpha > \mu$ implies that the input $x$ should be much smaller than its modulus $bb_\alpha$ (i.e., $|x| \ll \dfrac{bb_\alpha}{2}$)} %In order to satisfy $b_{\alpha} \geq 2\cdot(l + \lambda)$ where $l$ is fixed, $\lambda$ should be small. This means that $\mu \in [0, \lambda]$ has to be small, which consequently requires $x$ to be sufficiently small compared to $b\cdot b_\alpha$ (i.e., $x \ll b\cdot b_\alpha$). Therefore, a satisfactory $b_\alpha \geq 2\cdot(l + \lambda)$ can exist only if $x \ll b\cdot b_\alpha$. 

$ $


\textbf{\underline{Main Steps}}

\begin{enumerate}
\item $\hat{x} = |x|_b = \textsf{ModDrop}(x, bb_\alpha, b)$ 

\item $x_\alpha = |x|_{b_\alpha} = \textsf{ModDrop}(x, bb_\alpha, b_\alpha)$
%$\beta_{\langle \hat{x}, b\rightarrow b_\alpha \rangle} = |(\textsf{FastBConv}(\hat{x}, b, b_\alpha) - x_\alpha)\cdot b^{-1}|_{b_\alpha}$
\item $\gamma = |(\textsf{FastBConv}(\hat{x}, b, b_\alpha) - x_\alpha)\cdot b^{-1}|_{b_\alpha}$
%= |(\textsf{FastBConv}(\hat{x}, b, b_\alpha) - x_\alpha)\cdot b^{-1}|_{b_\alpha}$ \textcolor{red}{ \# $ = |(\textsf{FastBConv}(x, b, b_\alpha) - x_\alpha)\cdot b^{-1}|_{b_\alpha} = |(\textsf{FastBConv}(\hat{x}, b, b_\alpha) - x_\alpha)\cdot b^{-1}|_{b_\alpha}$}

\item $\textsf{FastBConvEx}(x, bb_\alpha, q) = \Big|\textsf{FastBConv}(\hat{x}, b, q) - \gamma \cdot b\Big|_q = |x|_q$

\end{enumerate}

\end{tcolorbox}
                                        
We will prove why $\Big|\textsf{FastBConv}(\hat{x}, b, q) - \gamma \cdot b\Big|_q = |x|_q$. 

\begin{myproof}



\begin{enumerate}



\item $\textsf{FastBConv}(\hat{x}, b, b_\alpha) $%$ = \Bigg(\sum\limits_{i=1}^{l}|\hat{x}_i\cdot b_i \cdot b^{-1} |_{b_i} \cdot \dfrac{b}{b_i}\Bigg) \bmod b_\alpha$ 

$ = |\hat{x} + ub|_{b_\alpha}$ \textcolor{red}{ \# where integer $|u| \leq \dfrac{l}{2}+1$}

$ = \Big||x|_{b} + ub\Big|_{b_\alpha}$ \textcolor{red}{ \# since $|x|_{b} = \hat{x}$ by definition}

$ = |x + \mu b + ub|_{b_\alpha}$ \textcolor{red}{ \# since $|x|_{b} = x + \mu b$ by definition}

$ $

\item $\gamma = |(\textsf{FastBConv}(\hat{x}, b, b_\alpha) - x_\alpha)\cdot b^{-1}|_{b_\alpha}$

$ = |(\textsf{FastBConv}(\hat{x}, b, b_\alpha) - x_\alpha - \mu b)\cdot b^{-1} + \mu|_{b_\alpha} $ \textcolor{red}{ \# by adding $|(-\mu b + \mu b)\cdot b^{-1}|_{b_\alpha}$}

$ = |(x + \mu b + ub - x_\alpha - \mu b)\cdot b^{-1} + \mu|_{b_\alpha} $ \textcolor{red}{ \# step 1 proved $ \textsf{FastBConv}(\hat{x}, b, b_\alpha) = |x + \mu b + u\cdot b|_{b_\alpha}$}

$ = |u + \mu|_{b_\alpha} $

$ = u + \mu $ \textcolor{red}{ \# because $-\dfrac{b_\alpha}{2} \leq u + \mu \leq \dfrac{b_\alpha}{2} - 1$ (since $u + \mu < l + \lambda \leq \dfrac{b_\alpha}{2}$, and $-\dfrac{b_\alpha}{2} \leq -(l+\lambda) < u + \mu$)}

$ $

\item $\textsf{FastBConvEx}(x, b, q) = \Big|\textsf{FastBConv}(\hat{x}, b, q) - \gamma \cdot b)\Big|_q $

$ = \Big|\hat{x} + u b - \gamma \cdot b)\Big|_q $ \textcolor{red}{ \# applying $\textsf{FastBConv}(\hat{x}, b, q) = \hat{x} + u b$ }

$ = \Big|(x + \mu b) + u b - \gamma \cdot b)\Big|_q $ \textcolor{red}{ \# applying $\hat{x} = |x|_b = x + \mu b$}

$ = \Big|(x + \mu b) + u b - (u + \mu) \cdot b)\Big|_q $ \textcolor{red}{ \# applying $\gamma = u + \mu$ from proof step 2}

$ = |x + \mu b + ub - ub - \mu b|_q $

$ = |x|_q $

\end{enumerate}

\end{myproof}

\para{Necessity of the Centered (i.e., Signed) Residue Representation:} In the proof step 2, we treated $|u + \mu|_{b_\alpha} = u + \mu$. To remove the modulo reduction operation, the canonical (i.e., unsigned) residue representation is inappropriate, because if $u + \mu$ becomes negative, then the residue will underflow and have to be wrapped around, which requires a modulo reduction operation. To prevent the occurrence of both overflow and underflow cases, we need the centered (i.e., signed) residue representation. 






\subsection{Decomposing Multiplication: \textsf{DecompMult\textsubscript{RNS}}}
\label{subsec:rns-decompmult}

In FHE, gadget decomposition (\autoref{subsec:gadget-decomposition}) is used to compute ciphertext-to-plaintext multiplication with a small noise. For example, BFV and CKKS's homomorphic key switching (Summary~\ref*{sec:glwe-key-switching} in \autoref{sec:glwe-key-switching}) uses gadget decomposition to compute $\textsf{RLWE}_{S',\sigma}(\Delta M) = B + A\cdot \textsf{RLWE}_{S', \sigma}(S)$ with a small noise (where each coefficient of the polynomial $A$ can be any value within the range of the ciphertext modulus $q$). As another example, the relinearization process of ciphertext-to-ciphertext multiplication in BFV (Summary~\ref*{subsubsec:bfv-mult-cipher-summary} in \autoref{subsubsec:bfv-mult-cipher-summary}), CKKS (Summary~\ref*{subsubsec:ckks-mult-cipher-summary} in \autoref{subsubsec:ckks-mult-cipher-summary}), and BGV (Summary~\ref*{subsec:bgv-mult-cipher} in \autoref{subsec:bgv-mult-cipher}) uses gadget decomposition to derive the synthetic ciphertext $\textsf{RLWE}_{S', \sigma}(D_2\cdot S^2)$ when computing $\textsf{RLWE}_{S',\sigma}(\Delta^2 M^{\langle 1 \rangle} M^{\langle 2 \rangle}) = D_0 + D_1\cdot S + D_2\cdot S^2 = \textsf{ct}_\alpha + \textsf{ct}_\beta$, where $\textsf{ct}_\alpha = (D_0, D_1)$, $\textsf{ct}_\beta = \textsf{RLWE}_{S', \sigma}(D_2\cdot S^2)$, $D_0 = B_1B_2$, $D_1 = A_1B_2 + A_2B_1$, and $D_2 = A_1A_2$. Using gadget decomposition, we showed the following relations: 

$\textsf{RLWE}_{S', \sigma}(A\cdot S) = \bm{\langle} \textsf{Decomp}^{\beta, l}(A), \text{ } \textsf{RLev}_{S', \sigma}^{\beta, l}(S) \bm{\rangle}$ \textcolor{red}{ \# used in key switching}

$\textsf{RLWE}_{S', \sigma}(D_2\cdot S^2) = \bm{\langle} \textsf{Decomp}^{\beta, l}(D_2), \text{ } \textsf{RLev}_{S, \sigma}^{\beta, l}( S^2) \bm{\rangle}$ \textcolor{red}{ \# used in relinearization}

$ $

However, if we convert a value (e.g., $x$) into an RNS vector, then it cannot be directly expressed in a gadget-decomposed form based on the $\beta$ and $l$ parameters. Instead, given the relationship between the value $x$ and its RNS residues is $x = \sum\limits_{i=1}^k x \cdot \dfrac{q}{q_i} \cdot \left|\left(\dfrac{q}{q_i}^{-1}\right)\right|_{q_i} \bmod q$, we can treat each RNS residue as a gadget-decomposed element. For example, suppose our goal is to decompose $\textsf{RLWE}_{S', \sigma}( A \cdot S)$, where the RNS vector of $A = (A_1, A_2, \cdots, A_k)$ and whose base moduli are $(q_1, q_2, \cdots, q_k)$. We can decompose $\textsf{RLWE}_{S', \sigma}( A \cdot S)$ as follows:

$\textsf{RLWE}_{S', \sigma}(A\cdot S) \bmod q$

$= \textsf{RLWE}_{S', \sigma}\left( S \cdot \left(A_{1}\dfrac{q}{q_1}\cdot\left|\left(\dfrac{q}{q_1}\right)^{-1}\right|_{q_1} + A_{2}\dfrac{q}{q_2}\cdot\left|\left(\dfrac{q}{q_2}\right)^{-1}\right|_{q_2} + \cdots + A_{k}\dfrac{q}{q_k}\cdot\left|\left(\dfrac{q}{q_k}\right)^{-1}\right|_{q_k}\right)\right)  \bmod q$ 

$= \textsf{RLWE}_{S', \sigma}\left(S \cdot A_{1}\dfrac{q}{q_1}\cdot\left|\left(\dfrac{q}{q_1}\right)^{-1}\right|_{q_1}\right) + \textsf{RLWE}_{S', \sigma}\left(S \cdot A_{2}\dfrac{q}{q_2}\cdot\left|\left(\dfrac{q}{q_2}\right)^{-1}\right|_{q_2}\right) + $

$\cdots + \textsf{RLWE}_{S', \sigma}\left(S \cdot A_{k}\dfrac{q}{q_k}\cdot\left|\left(\dfrac{q}{q_k}\right)^{-1}\right|_{q_k}\right) \bmod q$ 

$ $

$ $

$= A_{1}\cdot\textsf{RLWE}_{S', \sigma}\left(S \cdot \dfrac{q}{q_1}\cdot\left|\left(\dfrac{q}{q_1}\right)^{-1}\right|_{q_1}\right) + A_{2}\cdot\textsf{RLWE}_{S', \sigma}\left(S \cdot \dfrac{q}{q_2}\cdot\left|\left(\dfrac{q}{q_2}\right)^{-1}\right|_{q_2}\right) +$


$ \cdots + A_{k}\cdot\textsf{RLWE}_{S', \sigma}\left(S \cdot \dfrac{q}{q_k}\cdot\left|\left(\dfrac{q}{q_k}\right)^{-1}\right|_{q_k}\right) \bmod q$ 

$ $

$ $


$= \sum\limits_{i=1}^{k}\left(A_{i}\cdot \textsf{RLWE}_{S', \sigma}\left(S \cdot\dfrac{q}{q_i} \cdot \left| \left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right)\right) \bmod q$

$ $

$ $

, where $\left\{\textsf{RLWE}_{S', \sigma}\left(S \cdot\dfrac{q}{q_i} \cdot \left| \left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right)\right\}_{i=1}^{k}$ can be pre-generated as RNS key-switching keys.  

$ $

$ $

Applying the same reasoning as the above, we can also derive the following for relinearization:

$\textsf{RLWE}_{S, \sigma}(D_2 \cdot S^2) = \sum\limits_{i=1}^{k}\Bigg( D_{2, i}\cdot \textsf{RLWE}_{S, \sigma}\left(S^2 \cdot\dfrac{q}{q_i} \cdot \left| \left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right)\Bigg) \bmod q$

$ $

$ $

, where $\left\{\textsf{RLWE}_{S, \sigma}\left(S^2 \cdot\dfrac{q}{q_i} \cdot \left| \left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right)\right\}_{i=1}^{k}$ can be pre-generated as relinearization keys.

$ $

$ $

RNS-based multiplication decomposition is summarized as follows:

\begin{tcolorbox}[title={\textbf{\tboxlabel{\ref*{subsec:rns-decompmult}} \textsf{DecompMult\textsubscript{RNS}}}}]

For key-switching:

$ $

\textbf{\underline{Input}:} $A = (A_1, A_2, \cdots, A_k) \in \mathcal{R}_{\langle n, q_1 \rangle} \times \mathcal{R}_{\langle n, q_2 \rangle} \times \cdots \times \mathcal{R}_{\langle n, q_k \rangle}$, 

\phantom{Input: } $S_{\langle S', \textsf{RNS}\rangle} = \left\{ \textsf{RLWE}_{S', \sigma}\left(S\cdot \dfrac{q}{q_i}\cdot\left|\left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right) \right\}_{i=1}^{k}$ \textcolor{red}{ \# key-switching keys}

$ $

$ $

$\textsf{DecompMult\textsubscript{RNS}}(A, S_{\langle S', \textsf{RNS}\rangle}) = \textsf{RLWE}_{S', \sigma}(A \cdot S) $

$= \sum\limits_{i=1}^{k}\Bigg(A_{i}\cdot \textsf{RLWE}_{S', \sigma}\left(S \cdot\dfrac{q}{q_i} \cdot \left| \left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right)\Bigg) \bmod q$


$ $

\par\noindent\rule{\textwidth}{0.4pt}



For relinearization:

$ $

\textbf{\underline{Input}:} $D_2 = (D_{2,1}, D_{2,2}, \cdots, D_{2,k}) \in \mathcal{R}_{\langle n, q_1 \rangle} \times \mathcal{R}_{\langle n, q_2 \rangle} \times \cdots \times \mathcal{R}_{\langle n, q_k \rangle}$,

\phantom{Input: } $S_{\langle S, \textsf{RNS}\rangle}^2 = \left\{ \textsf{RLWE}_{S, \sigma}\left(S^2\cdot \dfrac{q}{q_i}\cdot\left|\left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right) \right\}_{i=1}^{k}$ \textcolor{red}{ \# relinearization keys}

$ $

$ $

$\textsf{DecompMult\textsubscript{RNS}}(D_2, S^2_{\langle S, \textsf{RNS}\rangle}) = \textsf{RLWE}_{S, \sigma}(D_2 \cdot S^2) $

$= \sum\limits_{i=1}^{k}\Bigg(D_{2,i}\cdot \textsf{RLWE}_{S, \sigma}\left(S^2 \cdot\dfrac{q}{q_i} \cdot \left| \left(\dfrac{q}{q_i}\right)^{-1}\right|_{q_i}\right)\Bigg) \bmod q$

\end{tcolorbox}




\subsection{Applying RNS Techniques to FHE Operations}
\label{subsec:rns-application}

This subsection will explain how the RNS primitives we have learned so far are used to handle FHE operations for RNS-based ciphertexts in BFV, CKKS, and BGV. 


\subsubsection{Addition and Multiplication of Polynomials}
\label{subsubsec:rns-application-basic}

In BFV, CKKS, and BGV, ciphertext-to-plaintext addition, ciphertext-to-ciphertext addition, and ciphertext-to-plaintext multiplication are performed by only involving modulo additions and multiplications among polynomial coefficients. Therefore, we can represent each polynomial coefficient as an RNS residue vector and compute coefficient-wise additions and multiplications by using RNS-based addition and multiplication of residues as explained in Summary~\ref*{subsec:crt-application} (\autoref{subsec:crt-application}). For example, suppose we have the following two polynomials $P^{\langle 1 \rangle}$ and $P^{\langle 2 \rangle}$:

$P^{\langle 1 \rangle} = \sum\limits_{a=0}^{n-1} c^{\langle 1 \rangle}_a \cdot X^a \in \mathcal{R}_{\langle n, q\rangle}$

$P^{\langle 2 \rangle} = \sum\limits_{b=0}^{n-1} c^{\langle 2 \rangle}_b \cdot X^b \in \mathcal{R}_{\langle n, q\rangle}$

$ $

In the RNS-variant FHE schemes, we express each polynomial's each coefficient as an RNS residue vector as follows:

$c^{\langle 1 \rangle}_a = (c^{\langle 1 \rangle}_{a,1}, c^{\langle 1 \rangle}_{a,2}, \cdots, c^{\langle 1 \rangle}_{a,k}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ \textcolor{red}{ \# for $a \in [0, n - 1]$}

$c^{\langle 2 \rangle}_b = (c^{\langle 2 \rangle}_{b,1}, c^{\langle 2 \rangle}_{b,2}, \cdots, c^{\langle 2 \rangle}_{b,k}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ \textcolor{red}{ \# for $b \in [0, n - 1]$}

$ $

Given the above RNS setup, when we add or multiply two polynomials, each coefficient-to-coefficient addition is computed as element-wise additions of two RNS residue vectors as follows:

$c^{\langle 1 \rangle}_a + c^{\langle 2 \rangle}_b \equiv \sum\limits_{i=1}^k (c^{\langle 1 \rangle}_{a,i} + c^{\langle 2 \rangle}_{b,i}) y_i z_i \bmod q $ \textcolor{red}{ \# where $y_i = \dfrac{q}{q_i}$, $z_i = |y_i^{-1}|_{q_i}$}

$\Longleftrightarrow (c^{\langle 1 \rangle}_{a,1} + c^{\langle 2 \rangle}_{b,1}, \text{ } c^{\langle 1 \rangle}_{a,2} + c^{\langle 2 \rangle}_{b,2}, \cdots, \text{ } c^{\langle 1 \rangle}_{a,k} + c^{\langle 2 \rangle}_{b,k}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$ 

$ $

Similarly, each coefficient-to-coefficient multiplication is computed as element-wise multiplications of two RNS residue vectors as follows:

$c^{\langle 1 \rangle}_a \cdot c^{\langle 2 \rangle}_b \equiv \sum\limits_{i=1}^k (c^{\langle 1 \rangle}_{a,i} \cdot c^{\langle 2 \rangle}_{b,i}) y_i z_i \bmod q $ 

$\Longleftrightarrow (c^{\langle 1 \rangle}_{a,1} \cdot c^{\langle 2 \rangle}_{b,1}, \text{ } c^{\langle 1 \rangle}_{a,2} \cdot c^{\langle 2 \rangle}_{b,2}, \cdots, \text{ } c^{\langle 1 \rangle}_{a,k} \cdot c^{\langle 2 \rangle}_{b,k}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k}$

$ $

Using the above isomorphism, we can efficiently compute ciphertext-to-plaintext addition, ciphertext-to-ciphertext addition, and ciphertext-to-plaintext multiplication of big polynomial coefficients (e.g., 1000 bits big) based on small RNS residues (e.g., 30 bits each). 


\subsubsection{Key Switching}
\label{subsubsec:rns-application-key-switching}

In BFV or CKKS, an RNS-based ciphertext's key-switching operation from $S \rightarrow S'$ is performed by computing the following formula in RNS vectors:

$\textsf{RLWE}_{S', \sigma}(\Delta M) = B + \bm{\langle} \textsf{Decomp}^{\beta, l}(A), \text{ } \textsf{RLev}_{S', \sigma}^{\beta, l}(S) \bm{\rangle}$


$ $

In the above formula, the computation of $\bm{\langle} \textsf{Decomp}^{\beta, l}(A), \text{ } \textsf{RLev}_{S', \sigma}^{\beta, l}(S) \bm{\rangle}$ can be performed by using $\textsf{DecompMult\textsubscript{RNS}}$ (Summary~\ref*{subsec:rns-decompmult} in \autoref{subsec:rns-decompmult}), after which $B$ can be added to it by using regular RNS-based addition. 

$ $

Similarly, in the case of the BGV, an RNS-based key-switching operation on a ciphertext from $S \rightarrow S'$ is performed by computing the following in RNS vectors:

$\textsf{RLWE}_{S', \sigma}(M) = B + \bm{\langle} \textsf{Decomp}^{\beta, l}(A), \text{ } \textsf{RLev}_{S', \sigma}^{\beta, l}(S) \bm{\rangle}$


\subsubsection{Input Slot Rotation}
\label{subsubsec:rns-rotation}

In BFV or CKKS, an RNS-based ciphertext's input slot rotation is performed by computing the following formulas in RNS vectors: 

$ $

\begin{enumerate}
\item $ \textsf{RLWE}_{S(X^{J(h)}), \sigma}\bm(\Delta M(X^{J(h)})\bm) = \bm(A(X^{J(h)})$, $B(X^{J(h)})\bm)$ \textcolor{red}{ \# where $J(h) = 5^h \bmod 2n$}

\item Key-switch $\textsf{RLWE}_{S(X^{J(h)}), \sigma}\bm(\Delta M(X^{J(h)})\bm)$ to $\textsf{RLWE}_{S(X), \sigma}\bm(\Delta M(X^{J(h)})\bm)$
\end{enumerate}

$ $

Step 1 is equivalent to re-positioning the coefficients within each polynomial and flipping their signs whenever they cross the boundary of the $n$-th degree term. This step can be done with RNS-based coefficients by moving around each set of RNS residue vectors as a whole whenever the coefficient they represent is re-positioned to a new degree term, and flipping the signs of the residues in the same RNS vector altogether whenever their representing coefficient's sign is to be flipped. Step 2's RNS-based key switching can be done in the same way as explained in the previous subsection (\autoref{subsubsec:rns-application-key-switching}). 

$ $

Similarly, in BGV, an RNS-based ciphertext's input slot rotation is performed by computing the following formulas in RNS vectors: 

$ $

\begin{enumerate}
\item $ \textsf{RLWE}_{S(X^{J(h)}), \sigma}\bm(M(X^{J(h)})\bm) = \bm(A(X^{J(h)})$, $B(X^{J(h)})\bm)$ \textcolor{red}{ \# where $J(h) = 5^h \bmod 2n$}

\item Key-switch $\textsf{RLWE}_{S(X^{J(h)}), \sigma}\bm(M(X^{J(h)})\bm)$ to $\textsf{RLWE}_{S(X), \sigma}\bm(M(X^{J(h)})\bm)$
\end{enumerate}

$ $

We can compute the above formulas in RNS by using the same strategy explained for BFV or CKKS. 



\subsubsection{BFV's Ciphertext-to-Ciphertext Multiplication}
\label{subsubsec:rns-cipher-mult-bfv}


BFV's ciphertext-to-ciphertext multiplication (Summary~\ref*{subsubsec:bfv-mult-cipher-summary} in \autoref{subsubsec:bfv-mult-cipher-summary}) comprises \textsf{ModRaise} $\rightarrow$ polynomial multiplication $\rightarrow$ relinearization $\rightarrow$ rescaling, where the order of relinearization and rescaling can be swapped. In RNS-based ciphertext-to-ciphertext multiplication, we will swap the order of these two steps. The procedure is as follows: (1) \textsf{ModRaise\textsubscript{RNS}} from $q \rightarrow qb$; (2) polynomial multiplication; (3) constant multiplication by $t$; (4) \textsf{ModSwitch} from $qb \rightarrow b$; (5)
\textsf{FastBConvEx} from $b \rightarrow q$; and (6) relinearization. Among these, step $3 \sim 5$ corresponds to the rescaling operation. We will explain how each of these steps works. %Throughout the explanation, we denote the polynomial constant to apply the RNS operations (i.e., the coefficients $\{a_0, \cdots, a_{n-1}\}$, $\{b_0, \cdots, b_{n-1}\}$ of polynomial $A, B$ of a ciphertext) as $x$.  

$ $

\begin{enumerate}

\item \textbf{\underline{\textsf{ModRaise\textsubscript{RNS}}} from $q \rightarrow qbb_\alpha$:}

Let $b$ be a new RNS base where $b > \Delta$ so that $qb$ is large enough to prevent a multiplied scaled plaintext in ciphertexts (i.e., $\Delta^2M^{\langle 1 \rangle}M^{\langle 2 \rangle}$) from exceeding its allowed limit (Summary~\ref*{subsec:bfv-enc-dec} in \autoref{subsec:bfv-enc-dec}) during ciphertext-to-ciphertext multiplication. $b_\alpha$ is also added for exact fast base conversion to be performed later. 
Specifically, we mod-raise the modulus of each polynomial coefficient of ciphertexts $(A^{\langle 1 \rangle}, B^{\langle 1 \rangle})$ and $(A^{\langle 2 \rangle}, B^{\langle 2 \rangle})$ as follows:

%$\textsf{ModRaise\textsubscript{RNS}}(x, q, qbb_\alpha)$ \textcolor{red}{ \# where $b > q$ and $b \approx q$, and $x$ one coefficient of a ciphertext polynomial} 

%$= (x_1, x_2, \cdots, x_{q_k}, \textsf{FastBConv}(x, q, b))$

%$= (x_1, x_2, \cdots, x_{q_k}, c_1, c_2, \cdots, c_l)$ \textcolor{red}{ \# where $c = x + uq \bmod b$ (where integer $|u| \leq \dfrac{k}{2}+1$)}
 
%$ 
%= (\chi_1, \chi_2, \cdots, \chi_{k+l}) 
%\text{ } \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$   

%$ $ 

%The above RNS vector represents the value $x + uq \bmod qb$  $(|u| \leq \dfrac{k}{2}+1)$. Since $b > q$, $|x + uq| \ll qb$. Therefore, $|x + uq|_{qb} = x + uq$. Accordingly, the ciphertexts ciphertexts $(A^{\langle 1 \rangle}, B^{\langle 1 \rangle})$ and $(A^{\langle 2 \rangle}, B^{\langle 2 \rangle})$ get updated to the following:

$(\hat{A}^{\langle 1 \rangle}, \hat{B}^{\langle 1 \rangle}) = (A^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}q, B^{\langle 1 \rangle} + U_B^{\langle 1 \rangle}q) \bmod qbb_\alpha$

$(\hat{A}^{\langle 2 \rangle}, \hat{B}^{\langle 2 \rangle}) =(A^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q, B^{\langle 2 \rangle} + U_B^{\langle 2 \rangle}q) \bmod qbb_\alpha$

$ $

, where each coefficient of $U_A^{\langle 1 \rangle}, U_B^{\langle 1 \rangle}, U_A^{\langle 2 \rangle}, U_B^{\langle 2 \rangle}$ is either $\{-1, 0, 1\}$. Decrypting these two (noisy) ciphertexts with the private key $S$ would give the following outputs:

$\hat{A}^{\langle 1 \rangle}\cdot S + \hat{B}^{\langle 1 \rangle} \bmod qbb_\alpha$

$ = (A^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}q) \cdot S + (B^{\langle 1 \rangle} + U_B^{\langle 1 \rangle}q) \bmod qbb_\alpha$

$ = A^{\langle 1 \rangle}\cdot S + B^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}q \cdot S + U_B^{\langle 1 \rangle}q \bmod qbb_\alpha$ 

$ = \Delta M^{\langle 1 \rangle} + E^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}q \cdot S + U_B^{\langle 1 \rangle}q  + K^{\langle 1 \rangle} q  \bmod qbb_\alpha$ \textcolor{red}{ \# where $ + K^{\langle 1 \rangle} q$ is the $q$-overflows of the decryption process}

$ $

$ \hat{A}^{\langle 2 \rangle}\cdot S + \hat{B}^{\langle 2 \rangle}  \bmod qbb_\alpha$ 

$ = (A^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q) \cdot S + (B^{\langle 2 \rangle} + U_B^{\langle 2 \rangle}q) \bmod qbb_\alpha$

$ = A^{\langle 2 \rangle}\cdot S + B^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q  \bmod qbb_\alpha$ 

$ = \Delta M^{\langle 2 \rangle} + E^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q + K^{\langle 2 \rangle} q  \bmod qbb_\alpha$


$ $

\item \textbf{\underline{Polynomial Multiplication:}}

 Compute $(\hat{B}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle}, \hat{A}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle} + \hat{A}^{\langle 2 \rangle}B^{\langle 1 \rangle}, \hat{A}^{\langle 1 \rangle}\hat{A}^{\langle 2 \rangle}) \bmod qbb_\alpha$, whose decryption relation is as follows:

$\hat{B}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle} + (\hat{A}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle} + \hat{A}^{\langle 2 \rangle}B^{\langle 1 \rangle})\cdot S + (\hat{A}^{\langle 1 \rangle}\hat{A}^{\langle 2 \rangle})\cdot S^2  \bmod qbb_\alpha$

$ = (\hat{A}^{\langle 1 \rangle}\cdot S + \hat{B}^{\langle 1 \rangle}) \cdot (\hat{A}^{\langle 2 \rangle}\cdot S + \hat{B}^{\langle 2 \rangle})  \bmod qbb_\alpha$

$ = (\Delta M^{\langle 1 \rangle} + E^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}q \cdot S + U_B^{\langle 1 \rangle}q + K^{\langle 1 \rangle} q) \cdot ( \Delta M^{\langle 2 \rangle} + E^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q + K^{\langle 2 \rangle} q)  \bmod qbb_\alpha$

$ $

\item \textbf{\underline{Constant Multiplication} by $\bm t$:} 

Step $3 \sim 5$ are equivalent to rescaling the plaintext's scaling factor from $\Delta^2 \rightarrow \Delta$ as well as switching the ciphertext's modulus from $qbb_\alpha$ to $q$.
In this step, we multiply $t$ to each coefficient of the resulting polynomials from the previous step as follows: 

$(t\cdot\hat{B}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle}, \text{ } t\cdot\hat{A}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle} + t\cdot\hat{A}^{\langle 2 \rangle}B^{\langle 1 \rangle}, \text{ } t\cdot\hat{A}^{\langle 1 \rangle}\hat{A}^{\langle 2 \rangle}) \bmod qbb_\alpha$

$ $

, which is equivalent to a ciphertext encrypting the following plaintext:

$ t\cdot(\Delta M^{\langle 1 \rangle} + E^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}q \cdot S + U_B^{\langle 1 \rangle}q  + K^{\langle 1 \rangle} q)\cdot(\Delta M^{\langle 2 \rangle} + E^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q  + K^{\langle 2 \rangle} q) \bmod qbb_\alpha$

$ $

%$t\cdot (x_1, x_2, \cdots, x_{q_k}, c_1, c_2, \cdots, c_l) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$

%$ = 
%(\nu_1, \nu_2, \cdots, \nu_{k+1}) (|t\cdot x_1|_{q_1}, |t\cdot x_2|_{q_2}, \cdots, |t\cdot x_{q_k}|_{q_k}, |t\cdot c_1|_{b_1}, |t\cdot c_2|_{b_2}, \cdots, |t\cdot c_l|_{b_l})$ 


%$ = (\nu_1, \nu_2, \cdots, \nu_{k+l}) \in \mathbb{Z}_{q_1} \times \mathbb{Z}_{q_2} \times \cdots \times \mathbb{Z}_{q_k} \times \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$

%$ $

%, where $\nu = t\cdot (x + u\cdot q) \bmod qb = |tx + tuq|_{qb}$. %Again, we assume that we chose a sufficiently large $b$ such that $t\cdot(x + uq) \ll qb$. Therefore, $|tx + tuq|_{qb} = tx + tuq$.

%$ $

\item \textbf{\underline{\textsf{ModSwitch\textsubscript{RNS}}} from $qbb_\alpha \rightarrow bb_\alpha$:}

We switch the modulus of the ciphertext from $qb$ to $b$ by using  \textsf{ModSwitch\textsubscript{RNS}} as follows:

%$\textsf{FastBConv\textsubscript{RNS}}\bm(\{|t\cdot c_i|_{q_i}\}_{i=1}^k, q, b\bm)$

%$ = (\hat\nu_1, \hat\nu_2, \cdots, \hat\nu_l) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$ 

%$ $

%, where $\hat\nu = \Big||tx + tuq|_{q} + u'q\Big|_b = \Big||tx|_{q} + u'q\Big|_b$ \textcolor{red}{\# $|u'| \leq \dfrac{l}{2}+1$}

$\left(\left\lceil\dfrac{t\cdot\hat{B}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle}}{q}\right\rfloor, \left\lceil\dfrac{t\cdot\hat{A}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle} + t\cdot\hat{A}^{\langle 2 \rangle}B^{\langle 1 \rangle}}{q}\right\rfloor, \left\lceil\dfrac{t\cdot\hat{A}^{\langle 1 \rangle}\hat{A}^{\langle 2 \rangle}}{q}\right\rfloor\right) \bmod bb_\alpha$

$ $

, which is (almost, considering the rounding error) equivalent to a ciphertext encrypting the following plaintext:

$ \left\lceil\dfrac{t\cdot(\Delta M^{\langle 1 \rangle} + E^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}q \cdot S + U_B^{\langle 1 \rangle}q  + K^{\langle 1 \rangle} q)\cdot(\Delta M^{\langle 2 \rangle} + E^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q  + K^{\langle 2 \rangle} q)}{q}\right\rfloor \bmod bb_\alpha$

$ $

$= \left\lceil (M^{\langle 1 \rangle} + \dfrac{t}{q}\cdot E^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}t \cdot S + U_B^{\langle 1 \rangle}t + K^{\langle 1 \rangle} t + \epsilon_d)\cdot(\Delta M^{\langle 2 \rangle} + E^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q + K^{\langle 2 \rangle} q)\right\rfloor \bmod bb_\alpha$ 

\textcolor{red}{ \# where $\epsilon_d = \dfrac{t}{q}\cdot \Delta M^{\langle 1 \rangle} - M^{\langle 1 \rangle}$ is a rounding error caused by treating $\dfrac{q}{t} \approx \left\lfloor\dfrac{q}{t}\right\rfloor = \Delta$}



$ $

%$\textsf{ModSwitch\textsubscript{RNS}}(\nu, qb, b)$

%$ = \{|q^{-1}|_{b_j} \cdot (\nu_j - \hat{\nu}_j) \bmod b_j\}_{j=1}^{l} \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$ 

%$ = (\tau_1, \tau_2, \cdots, \tau_l) \in \mathbb{Z}_{b_1} \times \mathbb{Z}_{b_2} \times \cdots \times \mathbb{Z}_{b_l}$

%$ $

%, where $\tau = |q^{-1}\cdot(\nu - \hat\nu)|_b$

%$= \Big|q^{-1}\cdot((tx + tuq) - (|tx|_{q} + u'q))\Big|_b$

%$ = \left|\dfrac{tx - |tx|_{q}}{q} + tu - u')\right|_b$ \textcolor{red}{ \# where $\dfrac{tx - |tx|_{q}}{q}$ is an integer}

%$ = \left|\left\lfloor\dfrac{tx}{q}\right\rfloor + tu - u')\right|_b$


%$ $

%$ $

\item \textbf{\underline{\textsf{FastBConvEx\textsubscript{RNS}}} from $b \rightarrow q$:} 

We exactly convert the base of the ciphertext from $bb_\alpha \rightarrow q$ as follows:

$\left(\left\lceil\dfrac{t\cdot\hat{B}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle}}{q}\right\rfloor, \left\lceil\dfrac{t\cdot\hat{A}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle} + t\cdot\hat{A}^{\langle 2 \rangle}B^{\langle 1 \rangle}}{q}\right\rfloor, \left\lceil\dfrac{t\cdot\hat{A}^{\langle 1 \rangle}\hat{A}^{\langle 2 \rangle}}{q}\right\rfloor\right) \bmod q$

$ $

, which is equivalent to a ciphertext encrypting the following plaintext:


$= \left\lceil (M^{\langle 1 \rangle} + \dfrac{t}{q}\cdot E^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}t \cdot S + U_B^{\langle 1 \rangle}t + K^{\langle 1 \rangle} t + \epsilon_d)\cdot(\Delta M^{\langle 2 \rangle} + E^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q + K^{\langle 2 \rangle} q)\right\rfloor \bmod q$

$ = \Big\lceil \Delta M^{\langle 1 \rangle} M^{\langle 2 \rangle} +  \dfrac{t}{q}\cdot \Delta M^{\langle 2 \rangle} E^{\langle 1 \rangle} + U_A^{\langle 1 \rangle}t \Delta M^{\langle 2 \rangle} \cdot S + U_B^{\langle 1 \rangle}t\Delta M^{\langle 2\rangle}  + M^{\langle 1 \rangle} E^{\langle 2 \rangle} + \dfrac{t}{q}\cdot E^{\langle 1 \rangle} E^{\langle 2 \rangle} $

\text{ } \text{ } $+ U_A^{\langle 1 \rangle}  E^{\langle 2 \rangle}t\cdot S + U_B^{\langle 1 \rangle} E^{\langle 2 \rangle}t + K^{\langle 1 \rangle}t\Delta M^{\langle 2 \rangle} + K^{\langle 1 \rangle}t E^{\langle 2 \rangle} 
+ \epsilon_d\cdot(\Delta M^{\langle 2 \rangle} + E^{\langle 2 \rangle} + U_A^{\langle 2 \rangle}q \cdot S + U_B^{\langle 2 \rangle}q + K^{\langle 2 \rangle} q)\Big\rfloor \bmod q $ 

$ \approx \Delta M^{\langle 1 \rangle} M^{\langle 2 \rangle} \bmod q $ \textcolor{red}{ \# all other terms are relatively much smaller than $\Delta M^{\langle 1 \rangle} M^{\langle 2 \rangle}$ in modulo $q$}

$ $

%$\left(\left\lceil\dfrac{t\cdot\hat{B}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle}}{q}\right\rfloor, \left\lceil\dfrac{t\cdot\hat{A}^{\langle 1 \rangle}\hat{B}^{\langle 2 \rangle} + t\cdot\hat{A}^{\langle 2 \rangle}B^{\langle 1 \rangle}}{q}\right\rfloor, \left\lceil\dfrac{t\cdot\hat{A}^{\langle 1 \rangle}\hat{A}^{\langle 2 \rangle}}{q}\right\rfloor\right) \bmod q$

%$\hat{\tau} = \textsf{ModDrop}(\tau, b, \hat{b})$ 

%$\beta_{\hat{\tau}} = (\textsf{FastBConv}(\hat{\tau}, \hat{b}, b_\alpha) - \hat{\tau})\cdot \hat{b}^{-1}$ \textcolor{red}{ \# where $b_\alpha = \dfrac{b}{\hat b}$ is one prime factor of the base $b$}

%$ $

%$\textsf{FastBConvEx}(\tau, b, q) = \Big|\textsf{FastBConv}(\hat{\tau}, \hat{b}, q) - |\beta_{\hat{\tau}}|_{b_{\alpha}} \cdot\hat{b}\Big|_q $

%$= |\tau|_q$

%$ $

%$ = \left|\left\lfloor\dfrac{tx}{q}\right\rfloor + tu + u')\right|_q$

%$ $

%$ = \left\lfloor\dfrac{tx}{q}\right\rfloor + tu + u'$

%$ \approx \dfrac{x}{\Delta} + tu + u'$ \textcolor{red}{ \# where $u$ and $u'$ can be reduced down to $\{-1, 0, 1\}$ by using \textsf{SmallMont} (\autoref{subsec:rns-smallmont})}


\item \textbf{\underline{Relinearization}:} 

Once we have derived the rescaled polynomial triple $(D'_0, D'_1, D'_2) \bmod q$, the final relinearization step is equivalent to deriving the synthetic ciphertexts $\textsf{ct}_\alpha$ and $\textsf{ct}_\beta$ and then computing $\textsf{ct}_\alpha + \textsf{ct}_\beta$. $\textsf{ct}_\alpha$ is simply $(D'_0, D'_1)$, and we can derive $\textsf{ct}_\beta = \textsf{RLWE}_{S, \sigma}(D_2 \cdot S^2)$ by using the \textsf{DecompMult\textsubscript{RNS}} operation (Summary~\ref*{subsec:rns-decompmult} in \autoref{subsec:rns-decompmult}). The final ciphertext-to-ciphertext addition of $\textsf{ct}_\alpha + \textsf{ct}_\beta$ can be performed by using regular RNS addition.

\end{enumerate}


\subsubsection{CKKS's Ciphertext-to-Ciphertext Multiplication}
\label{subsubsec:rns-cipher-mult-ckks}

CKKS's ciphertext-to-ciphertext multiplication (Summary~\ref*{subsubsec:ckks-mult-cipher-summary} in \autoref{subsubsec:ckks-mult-cipher-summary}) is almost the same as BFV's, except that CKKS does not need the \textsf{ModRaise} operation in the beginning (because each multiplicative level's modulus $q_l$ is large enough to hold a multiplied scaled plaintext $\Delta^2M^{\langle 1 \rangle}M^{\langle 2 \rangle}$). Therefore, CKKS's RNS-based multiplication is the same as BFV's except that it does not require step 1 (\textsf{ModRaise}), step 3 (constant multiplication by $t$), and step 5 (exact fast base conversion). Since a CKKS ciphertext's scaling factor $\Delta$ is approximately the same as the prime modulus factor of each multiplicative level, each ciphertext-to-ciphertext multiplication only needs to perform a 
modulus switch to a lower level.
%\textsf{ModSwitch\textsubscript{RNS}} to the lower level.


\subsubsection{BGV's Ciphertext-to-Ciphertext Multiplication}
\label{subsubsec:rns-cipher-mult-bgv}

BGV's ciphertext-to-ciphertext multiplication (Summary~\ref*{subsec:bgv-mult-cipher} in \autoref{subsec:bgv-mult-cipher}) is almost the same as CKKS's, except that BGV uses its own modulus switch ($\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$ as described in Summary~\ref*{subsec:bgv-modulus-switch} in \autoref{subsec:bgv-modulus-switch}) during the rescaling step. Therefore, BGV's RNS-based ciphertext-to-ciphertext multiplication is the same as CKKS's, except that \textsf{ModSwitch\textsubscript{RNS}} is replaced by $\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$.


\subsubsection{BFV's Bootstrapping}
\label{subsubsec:rns-bfv-bootstrapping}

BFV's original bootstrapping procedure (Summary~\ref*{subsubsec:bfv-bootstrapping-summary} in \autoref{subsubsec:bfv-bootstrapping-summary}) is as follows: (1) modulus switch from $q \rightarrow p^\varepsilon$; (2) homomorphic decryption; (3) \textsf{CoeffToSlot}; (4) \textsf{EvalExp}; (5) \textsf{SlotToCoeff}; and (6) re-interpretation. 

However, in RNS, we cannot mod-switch to $p^\varepsilon$ because RNS's base moduli have to be co-prime to each other, whereas the factors of $p^\varepsilon$ are not. To avoid this issue, RNS-based BFV's bootstrapping instead performs the following: (1) \textsf{ModRaise\textsubscript{RNS}} from $q \rightarrow qbb_\alpha$, where $bb_\alpha$ is an auxiliary base; (2) coefficient multiplication by $p^\varepsilon$; (3) \textsf{ModSwitch\textsubscript{RNS}} from $qbb_\alpha \rightarrow bb_\alpha$; (4) \textsf{FastBConvEx} from $bb_\alpha \rightarrow q$; (5) homomorphic decryption to adjust the scaling factor of the plaintext; (6) \textsf{CoeffToSlot}; (7) \textsf{EvalExp}; (8) \textsf{SlotToCoeff}; and (9) re-interpretation. The detailed procedure is described as follows:

$ $

\textbf{\underline{Input}:} The input BFV ciphertext to bootstrap is $(A, B) \bmod q$, which would decrypt to:  

$A\cdot S + B = \Delta M + E + Kq$ \textcolor{red}{ \# where $\Delta = \dfrac{q}{p^r}$}

$ $

\begin{enumerate}

\item \textbf{\underline{\textsf{ModRaise\textsubscript{RNS}}} from $q \rightarrow qbb_\alpha$: } 

Mod-raise ciphertext $(A, B) \bmod q$ to $(A, B) \bmod qbb_\alpha$, which would decrypt to:  

$A\cdot S + B = \Delta M + E + Kq + Uq \pmod{ qbb_\alpha}$ 

\textcolor{red}{ \# where $Uq$ is the \textsf{FastBConv} + \textsf{SmallMont} error, and $U$'s coefficients are either $\{-1, 0, 1\}$}

$ $

\item \textbf{\underline{Coefficient Multiplication} by $p^\varepsilon$: } 

Multiply the coefficients of $(A, B) \bmod q$ by $p^\varepsilon$ to update the ciphertext to  $(p^\varepsilon A,p^\varepsilon B) \bmod{ pbb_\alpha}$, which would decrypt to: 

$p^\varepsilon A\cdot S + p^\varepsilon B = \Delta p^\varepsilon M + p^\varepsilon E + p^\varepsilon Kq + p^\varepsilon Uq \pmod{qbb_\alpha}$

$ $

\item \textbf{\underline{\textsf{ModSwitch\textsubscript{RNS}}} from $qbb_\alpha \rightarrow bb_\alpha$: } 

Mod-switch the ciphertext $(p^\varepsilon A,p^\varepsilon B) \bmod pbb_\alpha$ to $\left(\left\lceil\dfrac{p^\varepsilon A}{q}\right\rfloor,\left\lceil\dfrac{p^\varepsilon B}{q}\right\rfloor\right) \pmod{bb_\alpha}$, which would decrypt to: 

$\left\lceil\dfrac{p^\varepsilon A}{q}\right\rfloor\cdot S + \left\lceil\dfrac{p^\varepsilon B}{q}\right\rfloor = \dfrac{\Delta p^\varepsilon M}{q} + \dfrac{p^\varepsilon E}{q} + \dfrac{p^\varepsilon Kq}{q} + \dfrac{p^\varepsilon Uq}{q} + \epsilon  \pmod {bb_\alpha}$ 

\textcolor{red}{ \# $\epsilon$ is a small rounding error}

$ = p^{\varepsilon - r}M + \dfrac{p^\varepsilon E}{q} + p^\varepsilon K + p^\varepsilon U +\epsilon \pmod{ bb_\alpha}$ 

$ $

\item \textbf{\underline{\textsf{FastBConvEx}} from $bb_\alpha \rightarrow q$: } 

Exact fast base conversion of $(p^\varepsilon A, p^\varepsilon B) \bmod bb_\alpha$ to $(p^\varepsilon A, p^\varepsilon B) \bmod q$, which would decrypt to:

$p^{\varepsilon - r}M + \dfrac{p^\varepsilon E}{q} + p^\varepsilon K + p^\varepsilon U +\epsilon \bmod q$

$ $

\item \textbf{\underline{Homomorphic Decryption}:} 

Now, we have the ciphertext $(p^\varepsilon A, p^\varepsilon B) \bmod q = \textsf{RLWE}_{S, \sigma}\left(p^{\varepsilon - r}M + \dfrac{p^\varepsilon E}{q} + p^\varepsilon K + p^\varepsilon U +\epsilon\right) \bmod q$. We do homomorphic decryption by using the encrypted private key $\textsf{RLWE}_{S, \sigma}(\hat\Delta S)$, where $\hat\Delta = \left\lfloor\dfrac{q}{p^\varepsilon}\right\rfloor$. The output is $\textsf{RLWE}_{S, \sigma}\bm(\hat\Delta\cdot(p^{\varepsilon - r}M + \dfrac{p^\varepsilon E}{q} + p^\varepsilon K + p^\varepsilon U +\epsilon)\bm) \bmod q$. 

$ $

\item Perform \textsf{CoeffToSlot}, digit extraction, and \textsf{SlotToCoeff}. These operations can be performed by only regular RNS-based additions and multiplications. The final digit-extracted ciphertext is $\textsf{RLWE}_{S, \sigma}\bm(\hat\Delta\cdot(p^{\varepsilon - r}\cdot M +  Kp^\varepsilon +  Up^\varepsilon)\bm)$, where all noise values smaller than the (base-$p$) $(\varepsilon-r)$-th digits are eliminated. 

$ $

\item \textbf{\underline{Scaling Factor Re-interpretation:}} 

Theoretically re-interpret the ciphertext without any additional mathematical computation. The ciphertext $\textsf{RLWE}_{S, \sigma}\bm(\hat\Delta\cdot(p^{\varepsilon - r}\cdot M +  Kp^\varepsilon +  Up^\varepsilon)\bm)$ is mathematically the same as: 

$\textsf{RLWE}_{S, \sigma}\bm(\hat\Delta\cdot(p^{\varepsilon - r}\cdot M +  Kp^\varepsilon +  Up^\varepsilon)\bm) $

$= \textsf{RLWE}_{S, \sigma}\bm(\Delta M + (K + U)\cdot q\bm) $ \textcolor{red}{ \# since $\Delta = \dfrac{q}{p^r}$, and $\hat\Delta = \dfrac{a}{p^\varepsilon}$}

$= \textsf{RLWE}_{S, \sigma}\bm(\Delta M\bm) \bmod q$.


\end{enumerate}

\begin{comment}
\begin{enumerate}


\item Initially, the plaintext's scaling factor $\Delta = \left\lfloor\dfrac{q}{p^{r}}\right\rfloor$. We run \textsf{ModRaise\textsubscript{RNS}} from $q \rightarrow q\cdot b
\cdot b_\alpha$, which generates an additional noise $u\cdot q$ (where integer $|u| \leq \dfrac{k}{2}+1$ without \textsf{SmallMont}, and $u \in \{-1, 0, 1\}$ with \textsf{SmallMont}).  

\item Constant multiplication by $p^\varepsilon$ to the coefficients of the ciphertext polynomials $(A, B) \bmod qbb_\alpha$. The ciphertext modulus $qbb_\alpha$ is large enough to hold $\Delta M \cdot p^{\varepsilon}$ without overflowing $qbb_\alpha$.

\item \textsf{ModSwitch\textsubscript{RNS}} $q\cdot b \cdot b_\alpha \rightarrow b \cdot b_\alpha$.  

\item \textsf{FastBConvEx} from $b
\cdot b_\alpha \rightarrow q$. We can use this function, because the input values (i.e,. the coefficients of $\left\lceil\dfrac{p^\varepsilon\cdot A}{q}\right\rfloor$ and $\left\lceil\dfrac{p^\varepsilon\cdot B}{q}\right\rfloor$) at this point are expected to be much smaller than $b
\cdot b_\alpha$. After running \textsf{FastBConvEx}, we can view the plaintext's scaling factor to be equivalent to $\dfrac{q}{p^r} \cdot \dfrac{p^{\varepsilon}}{q} = p^{\varepsilon - r}$.

\end{enumerate}

$ $

After the above steps, the remaining steps (i.e., homomorphic decryption, \textsf{CoeffToSlot}, \textsf{EvalExp}, \textsf{SlotToCoeff}, and re-interpretation) can be performed by regular RNS-based addition and multiplication operations. 

\end{comment}


\subsubsection{CKKS's Bootstrapping}
\label{subsubsec:rns-ckks-bootstrapping}

CKKS's original bootstrapping procedure (Summary~\ref*{subsubsec:ckks-bootstrapping-summary} in \autoref{subsubsec:ckks-bootstrapping-summary}) is as follows:
(1) \textsf{Modraise}; (2) homomorphic decryption; (3) \textsf{CoeffToSlot}; (4) \textsf{EvalExp}; (5) \textsf{CoeffToSlot}; (6) Re-interpretation. In the RNS-based CKKS bootstrapping, we perform \textsf{ModRaise\textsubscript{RNS}} at step 1, and all other steps are computed by using regular RNS-based addition and multiplication operations. Step 1's \textsf{ModRaise\textsubscript{RNS}} operation generates a 
$u\cdot q_0$ noise (where $u \in \{-1, 0, 1\}$ using \textsf{SmallMont}) for each polynomial coefficient during \textsf{FastBConv}. Therefore, step 2's homomorphic decryption outputs $\Delta M + E + W\cdot q_0 + K\cdot q_0$, where $W\cdot q_0$ represents the aggregation of all coefficient noise terms which are multiplied with the $q_0$-overflow noises generated by \textsf{FastBConv} and \textsf{SmallMont}. The $W\cdot q_0 + K\cdot q_0$ term gets eliminated by step 4's \textsf{EvalExp} which performs approximated modulo reduction based on a sine-graph evaluation whose period is $q_0$. 




\subsubsection{BGV's Bootstrapping}
\label{subsubsec:rns-bgv-bootstrapping}

BGV's original bootstrapping procedure (\autoref{subsec:bgv-bootstrapping}) is as follows:
(1) modulus switch from $q_l \rightarrow \hat{q}$; (2) ciphertext coefficient multiplication by $p^{\varepsilon - 1}$; (3) \textsf{ModRaise}; (4) \textsf{CoeffToSlot}; (5) \textsf{EvalExp}; (6) homomorphic multiplication by $|p^{-(\varepsilon-1)}|_{p^\varepsilon}$; (7) \textsf{SlottToCoeff}; (8) noise term re-interpretation. Given this procedure, the RNS-based bootstrapping steps are as follows:

$ $
\begin{comment}
\clearpage 


Suppose the target BGV ciphertext to bootstrap is $(A, B) \bmod q_l$, where the plaintext modulus (i.e., noise scaling factor) is $p$.

\begin{enumerate}

\item \textsf{\textbf{\underline{ScaleUp}}} the ciphertext $(A, B) \bmod q_l$ to $(\hat{q}A, \hat{q}B) \bmod q_l\hat{q} = (A', B') \bmod q_l\hat{q}$, which satisfies the relation:

$A'\cdot S + B' = \hat{q}M + \hat{q}pE + Kq_l\hat{q}$

$ $

We view the plaintext message $(\hat{q}M \bmod p)$ as $(M \bmod p)$ with the correction factor $\kappa = [\hat{q}]_p$. Note that \textsf{ScaleUp} by $\hat{q}$ is different from coefficient multiplication by $\hat{q}$, because \textsf{ScaleUp} by $\hat{q}$ does not reduce modulo $q_l$ during its operation, whereas coefficient multiplication by $\hat{q}$ reduces modulo $q_l$. 

$ $

\item \textbf{\underline{$\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$}} the ciphertext $(A', B') \bmod q_l\hat{q}$ to $(A'', B'') \bmod \hat{q}$, whose plaintext message is still $M \bmod p$ with the message correction factor $\kappa = [\hat{q}]_p$. The new ciphertext satisfies the relation:

$A''\cdot S + B'' = M + \hat{q}pE'' + K\hat{q}$ \textcolor{red}{\# the noise factor increased from $E \rightarrow E''$, and the message correction factor $\kappa = \hat{q}$}

$ $

\item \textbf{\underline{Coefficient Multiplication}} by $p^{\varepsilon-1}$ to update the ciphertext $(A'', B'') \bmod \hat{q}$ to $(p^{\varepsilon-1}A'', p^{\varepsilon-1}B'') \bmod \hat{q} = (A''', B''') \bmod \hat{q}$. As of now, we view its plaintext to be scaled up from $M \bmod p$ to $p^{\varepsilon-1} \cdot M \bmod p^e$ (which also scales up the plaintext modulus and the noise scaling factor from $p \rightarrow p^\varepsilon$). The new ciphertext satisfies the relation: 

$A'''\cdot S + B''' = p^{\varepsilon-1}M + p^\varepsilon \hat{q}pE'' + Kq_l\hat{q}$ \textcolor{red}{\# the noise factor increased from $E \rightarrow E''$, and the message correction factor is still $\kappa = \hat{q}$}

$ $

$ = p^{\varepsilon-1}M + p^\varepsilon E''' + K'''\hat{q} \pmod{\hat{q}}$ \textcolor{red}{ \# where we denote $E''' = \hat{q}pE''$, and reduce $Kq_l \equiv K''' \bmod \hat{q}$, where $K''' \leq n$}

$ $

\item We do either: (i) \textsf{\underline{\textbf{FastBConv}}} from $\hat{q} \rightarrow q_L$ (if $\hat{q}$ does not divide $q_L$); or (ii) \textsf{\underline{\textbf{ModRaise\textsubscript{RNS}}}} (if $\hat{q}$ divides $q_L$). In both cases, we get a $\hat{q}$-overflow noise. 

$ $

\item We do \textsf{CoeffToSlot}, digit extraction, and \textsf{SlotToCoeff} to eliminate the $\hat{q}$-overflow noise. 

$ $

\item We multiply the polynomial coefficients of the final ciphertext with the inverse of the correction factor $[\hat{q}^{-1}]_p$, which resets the correction factor back to 1. 

\end{enumerate}

$ $

\clearpage



Suppose the target BGV ciphertext to bootstrap is $(A, B) \bmod q_l$, where the plaintext modulus (i.e., noise scaling factor) is $p$. 


\begin{enumerate}

\item \textbf{\underline{Coefficient Multiplication by $p^{\varepsilon-1}$}} to update $(A, B) \bmod q_l$ to $(p^{\varepsilon-1}A, p^{\varepsilon-1}B) \bmod q_l$, which we denote as $(A', B') \bmod q_l$. This ciphertext satisfies the relation:

$A' \cdot S + B' = p^{\varepsilon-1}M + p^\varepsilon E + Kq_l$ \textcolor{red}{ \# $||K||_\infty \leq n$ ($||K||_\infty$ denotes the maximum coefficient of $K$)}

$ $


\item \textbf{\underline{\textsf{ModRaise\textsubscript{RNS}}}} $(A', B') \bmod q_l$ from $q_l \rightarrow q_l\hat{q}$, where $\hat{q} \equiv 1 \bmod p^{\varepsilon}$. We denote the mod-raised ciphertext is $(A'', B'') \bmod q_l\hat{q}$, where each coefficient of $A''$ and $B''$ has at most one $\pm q_l$ overflow error. After \textsf{ModRaise\textsubscript{RNS}}, the new ciphertext satisfies the following relation:

$A'' \cdot S + B'' = p^{\varepsilon-1}M + p^\varepsilon E + Uq_l \pmod{q_l\hat{q}}$ \textcolor{red}{\# where $Uq_l$ includes $Kq_l$ plus the noise generated by \textsf{ModRaise\textsubscript{RNS}}'s \textsf{FastBConv} with \textsf{SmallMont}}

$ $

\item \textbf{\underline{$\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$}} from $q_l\hat{q} \rightarrow \hat{q}$, \textcolor{blue}{which effectively divides the $Uq_l$ error term by $q_l$ \textit{(uncertain if this is true)}}. Since the coefficients of $U$ are small relative to $p^\varepsilon$, they will stay in the (base-$p^\varepsilon$) low-digit area of the plaintext encrypted in the mod-switched new ciphertext $(A''', B''') \bmod \hat{q}$. This new ciphertext satisfies the relation:

$A'''S + B''' = p^{\epsilon-1}M + p^\varepsilon E' + U \pmod{\hat{q}}$ \textcolor{red}{ \# $E\rightarrow E'$ is an increase due to BGV's \textsf{ModSwitch} noise}

$ $

\item We do either: (i) \textsf{\underline{\textbf{FastBConv}}} from $\hat{q} \rightarrow q_L$ (if $\hat{q}$ does not divide $q_L$); or (ii) \textsf{\underline{\textbf{ModRaise\textsubscript{RNS}}}} (if $\hat{q}$ divides $q_L$). In both cases, we get a $\hat{q}$-overflow noise. The new ciphertext $(A'''', B'''') \bmod q_L$ satisfies the relation:

$A''''\cdot S + B'''' = p^{\varepsilon-1} M + p^{\varepsilon}E + U + U'\hat{q} \pmod{q_L}$ \textcolor{red}{ \# where $U'\hat{q}$ is a noise generated by this step}

$ $


\item The noises $U$ and $U'\hat{q}$ get removed by \textsf{CoeffToSlot}, digit extraction, and \textsf{SlotToCoeff}. 

\end{enumerate}

\clearpage
\end{comment}

Suppose the target BGV ciphertext to bootstrap is $(A, B) \bmod q_l$, where the plaintext modulus (i.e., noise scaling factor) is $p$. 

\begin{enumerate}

\item \textbf{\underline{$\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$}} from $q_l \rightarrow \hat{q}$ where $\hat{q}$ is a special modulus satisfying the following requirements: $\hat{q} \equiv 1 \bmod p^\varepsilon$, $\hat{q} \equiv 1 \bmod p$, $\hat{q}$ and $q_l$ are co-prime, and $\hat{q} < q_l$. 
\begin{comment}
This modulus switch is done by performing  \textsf{ModRaise\textsubscript{RNS}} from $q_l \rightarrow q_l\hat{q}$ and then $\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$ from $q_l\hat{q} \rightarrow \hat{q}$. 
The modulus switch updates the ciphertext from $(A, B) \bmod q_l$ to $(\hat{A}, \hat{B}) \bmod \hat{q}$.  Although \textsf{ModRaise\textsubscript{RNS}} from $q_l \rightarrow q_l\hat{q}$ would generate a $q_l$-multiple noise, the subsequent $\textsf{ModSwitch}_{\textsf{RNS}}^{\textsf{BGV}}$ $q_l\hat{q} \rightarrow \hat{q}$ divides this $q_l$-multiple noise by $q_l$, which will be later eliminated by the homomorphic digit extraction step. 
\end{comment}

$ $
 
\item \textbf{\underline{Constant multiplication}} by $p^{\varepsilon-1}$ to the coefficients of the ciphertext polynomials $(\hat{A}, \hat{B})$, which increases the underlying plaintext's noise scaling factor $\Delta$ and the plaintext modulus from $p \rightarrow p^{\varepsilon}$. This effectively updates the underlying plaintext to $p^{\varepsilon-1} M + p^{\varepsilon}E$. 

$ $

\item \textbf{\underline{\textsf{ModRaise\textsubscript{RNS}}}} from $\hat{q} \rightarrow q_L$, which generates an additional noise $|u\cdot \hat{q}|_{q_L}$ (where $u \in \{-1, 0, 1\}$ using \textsf{SmallMont}). At this point, the ciphertext is $\textsf{RLWE}_{S, \sigma}(p^{\varepsilon-1} M + p^{\varepsilon}E + \hat{q}K) \bmod q_L$, whose underlying plaintext is:

$p^{\varepsilon-1} M + p^{\varepsilon}E + \hat{q}K$

$= p^{\varepsilon-1} M + K \bmod p^{\varepsilon}$ \textcolor{red}{\# since $\hat{q} \equiv 1 \bmod p^{\varepsilon}$}

\end{enumerate}

$ $

After the above steps, the remaining steps (i.e., \textsf{CoeffToSlot}, \textsf{EvalExp}, homomorphic multiplication by $|p^{-(\varepsilon-1)}|_{p^\varepsilon}$, \textsf{SlotToCoeff}, and re-interpretation) can be performed by regular RNS-based addition and multiplication operations. 


\subsubsection{Noise Impact of RNS Operations}
\label{subsubsec:rns-noise}

When RNS techniques are used in FHE operations, the noise generated by \textsf{FastBConvEx\textsubscript{RNS}}, \textsf{ModRaise\textsubscript{RNS}}, and \textsf{ModSwitch\textsubscript{RNS}} is directly added to each coefficient of the ciphertext polynomials $A$ and $B$. Since the decryption relation is $A\cdot S + B$, even the noise added to the coefficients of the polynomial $A$ gets multiplied by a large factor due to the polynomial multiplication with $S$. Therefore, it is important to always ensure to reduce the generated noise of each \textsf{FastBConvEx\textsubscript{RNS}} by using it with \textsf{SmallMont}. 

\subsubsection{Python Source Code of RNS Primitives}
\label{subsubsec:rns-source-code}

We provide a \href{https://github.com/fhetextbook/fhe-textbook/blob/main/source%20code/rns.py}{\underline{Python script}} implementing the following exemplary RNS primitives: \textsf{FastBConv}, 
\textsf{ModRaise\textsubscript{RNS}}, 
\textsf{ModDrop\textsubscript{RNS}}, 
\textsf{ModSwitch\textsubscript{RNS}},
\textsf{SmallMont}, and 
\textsf{BaseBConvEx}. 





